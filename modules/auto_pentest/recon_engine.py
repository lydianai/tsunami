#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
================================================================================
    TSUNAMI RECON ENGINE v5.0
    Automated Reconnaissance Module
================================================================================

    Features:
    - Port scanning (python-nmap)
    - Service detection
    - OS fingerprinting
    - DNS enumeration
    - Subdomain discovery
    - Technology detection

    IMPORTANT: For authorized testing only.
================================================================================
"""

import socket
import ssl
import re
import json
import logging
import threading
import ipaddress
import dns.resolver
import dns.reversename
import dns.zone
import dns.query
from datetime import datetime
from typing import Dict, List, Optional, Set, Tuple, Any
from dataclasses import dataclass, field, asdict
from concurrent.futures import ThreadPoolExecutor, as_completed
from enum import Enum

import requests

# python-nmap
try:
    import nmap
    NMAP_AVAILABLE = True
except ImportError:
    NMAP_AVAILABLE = False

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class ScanType(Enum):
    """Scan types"""
    TCP_SYN = "syn"
    TCP_CONNECT = "connect"
    UDP = "udp"
    COMPREHENSIVE = "comprehensive"
    STEALTH = "stealth"


@dataclass
class PortScanResult:
    """Port scan result"""
    port: int
    protocol: str
    state: str
    service: str = ""
    version: str = ""
    product: str = ""
    extra_info: str = ""
    cpe: List[str] = field(default_factory=list)
    scripts: Dict[str, str] = field(default_factory=dict)


@dataclass
class ServiceInfo:
    """Service information"""
    port: int
    protocol: str
    name: str
    product: str = ""
    version: str = ""
    extra_info: str = ""
    hostname: str = ""
    os_type: str = ""
    device_type: str = ""
    cpe: List[str] = field(default_factory=list)
    vulnerabilities: List[str] = field(default_factory=list)


@dataclass
class HostInfo:
    """Host information"""
    ip: str
    hostname: str = ""
    hostnames: List[str] = field(default_factory=list)
    state: str = "unknown"
    os_match: str = ""
    os_accuracy: int = 0
    os_family: str = ""
    os_gen: str = ""
    mac_address: str = ""
    vendor: str = ""
    ports: List[PortScanResult] = field(default_factory=list)
    services: List[ServiceInfo] = field(default_factory=list)
    dns_records: Dict[str, List[str]] = field(default_factory=dict)
    subdomains: List[str] = field(default_factory=list)
    technologies: List[str] = field(default_factory=list)
    scan_time: datetime = field(default_factory=datetime.now)


class AuthorizationManager:
    """
    Authorization management for ethical testing.
    CRITICAL: All scans must be explicitly authorized.
    """

    def __init__(self):
        self._authorized_targets: Set[str] = set()
        self._authorized_ranges: List[ipaddress.IPv4Network] = []
        self._scope_file: Optional[str] = None
        self._authorization_token: Optional[str] = None

    def add_authorized_target(self, target: str):
        """Add single authorized target"""
        self._authorized_targets.add(target.lower())

    def add_authorized_range(self, cidr: str):
        """Add authorized IP range"""
        try:
            network = ipaddress.ip_network(cidr, strict=False)
            self._authorized_ranges.append(network)
        except ValueError as e:
            logger.error(f"Invalid CIDR range: {cidr} - {e}")

    def load_scope_file(self, filepath: str):
        """Load authorized targets from scope file"""
        self._scope_file = filepath
        try:
            with open(filepath, 'r') as f:
                for line in f:
                    line = line.strip()
                    if not line or line.startswith('#'):
                        continue
                    if '/' in line:
                        self.add_authorized_range(line)
                    else:
                        self.add_authorized_target(line)
            logger.info(f"Loaded scope from {filepath}")
        except Exception as e:
            logger.error(f"Failed to load scope file: {e}")

    def is_authorized(self, target: str) -> bool:
        """Check if target is authorized for testing"""
        target_lower = target.lower()

        # Check direct authorization
        if target_lower in self._authorized_targets:
            return True

        # Check if it's an IP and in authorized ranges
        try:
            ip = ipaddress.ip_address(target)
            for network in self._authorized_ranges:
                if ip in network:
                    return True
        except ValueError:
            # Not an IP, check as domain
            pass

        # Check wildcards
        for authorized in self._authorized_targets:
            if authorized.startswith('*.'):
                domain = authorized[2:]
                if target_lower.endswith(domain) or target_lower == domain:
                    return True

        return False

    def clear_authorizations(self):
        """Clear all authorizations"""
        self._authorized_targets.clear()
        self._authorized_ranges.clear()


class ReconEngine:
    """
    Automated Reconnaissance Engine

    Performs comprehensive reconnaissance including:
    - Port scanning
    - Service detection
    - OS fingerprinting
    - DNS enumeration
    - Subdomain discovery
    - Technology detection
    """

    # Common DNS record types
    DNS_RECORD_TYPES = ['A', 'AAAA', 'MX', 'NS', 'TXT', 'SOA', 'CNAME', 'PTR', 'SRV']

    # Subdomain wordlist (common prefixes)
    SUBDOMAIN_WORDLIST = [
        'www', 'mail', 'ftp', 'admin', 'api', 'dev', 'test', 'staging',
        'app', 'web', 'portal', 'secure', 'vpn', 'remote', 'login',
        'webmail', 'smtp', 'pop', 'imap', 'ns1', 'ns2', 'dns', 'git',
        'gitlab', 'github', 'jenkins', 'ci', 'cd', 'build', 'deploy',
        'monitor', 'status', 'docs', 'wiki', 'blog', 'shop', 'store',
        'static', 'cdn', 'assets', 'media', 'images', 'img', 'files',
        'backup', 'old', 'new', 'beta', 'alpha', 'v1', 'v2', 'api-v1',
        'mobile', 'm', 'internal', 'intranet', 'extranet', 'corp',
        'office', 'hr', 'crm', 'erp', 'db', 'database', 'mysql', 'sql',
        'redis', 'elastic', 'es', 'kibana', 'grafana', 'prometheus',
        'vault', 'consul', 'nomad', 'k8s', 'kubernetes', 'docker',
        'registry', 'repo', 'artifactory', 'nexus', 'sonar', 'jira',
        'confluence', 'slack', 'teams', 'zoom', 'meet', 'calendar',
        'auth', 'oauth', 'sso', 'identity', 'id', 'accounts', 'account'
    ]

    # Technology signatures
    TECH_SIGNATURES = {
        'nginx': [b'nginx', b'Server: nginx'],
        'apache': [b'Apache', b'Server: Apache'],
        'iis': [b'Microsoft-IIS', b'Server: Microsoft-IIS'],
        'tomcat': [b'Apache-Coyote', b'Tomcat'],
        'nodejs': [b'X-Powered-By: Express'],
        'php': [b'X-Powered-By: PHP', b'Set-Cookie: PHPSESSID'],
        'asp.net': [b'X-AspNet-Version', b'X-Powered-By: ASP.NET'],
        'django': [b'csrftoken', b'django'],
        'flask': [b'Werkzeug'],
        'rails': [b'X-Powered-By: Phusion Passenger', b'_rails_session'],
        'wordpress': [b'wp-content', b'wp-includes', b'wordpress'],
        'drupal': [b'Drupal', b'/sites/default', b'X-Generator: Drupal'],
        'joomla': [b'Joomla', b'/components/com_'],
        'cloudflare': [b'cloudflare', b'cf-ray'],
        'aws': [b'x-amz-', b'AmazonS3', b'aws-'],
        'azure': [b'azure', b'x-ms-'],
        'gcp': [b'x-goog-', b'google cloud'],
    }

    def __init__(self):
        self.auth_manager = AuthorizationManager()
        self._scanner: Optional[nmap.PortScanner] = None
        self._results: Dict[str, HostInfo] = {}
        self._lock = threading.Lock()

        if NMAP_AVAILABLE:
            self._scanner = nmap.PortScanner()
            logger.info("[RECON] nmap module loaded")
        else:
            logger.warning("[RECON] python-nmap not available, limited functionality")

    def set_scope(self, targets: List[str], ranges: List[str] = None):
        """
        Set authorized scope for testing

        Args:
            targets: List of authorized domains/IPs
            ranges: List of authorized CIDR ranges
        """
        self.auth_manager.clear_authorizations()

        for target in targets:
            self.auth_manager.add_authorized_target(target)

        if ranges:
            for cidr in ranges:
                self.auth_manager.add_authorized_range(cidr)

        logger.info(f"[RECON] Scope set: {len(targets)} targets, {len(ranges or [])} ranges")

    def _verify_authorization(self, target: str) -> bool:
        """Verify target is authorized before scanning"""
        if not self.auth_manager.is_authorized(target):
            logger.error(f"[RECON] UNAUTHORIZED: {target} - Scan blocked")
            return False
        return True

    def scan_ports(self, target: str,
                   ports: str = "1-1000",
                   scan_type: ScanType = ScanType.TCP_SYN,
                   timeout: int = 300) -> Optional[HostInfo]:
        """
        Perform port scan on target

        Args:
            target: Target IP or hostname (must be authorized)
            ports: Port range (e.g., "1-1000", "22,80,443", "1-65535")
            scan_type: Type of scan to perform
            timeout: Scan timeout in seconds

        Returns:
            HostInfo with scan results or None if unauthorized
        """
        if not self._verify_authorization(target):
            return None

        if not NMAP_AVAILABLE:
            logger.warning("[RECON] nmap not available, using socket scan")
            return self._socket_scan(target, ports)

        logger.info(f"[RECON] Starting port scan: {target} ports={ports}")

        # Build nmap arguments based on scan type
        arguments = "-sV --version-intensity 5"  # Service detection

        if scan_type == ScanType.TCP_SYN:
            arguments = "-sS -sV"
        elif scan_type == ScanType.TCP_CONNECT:
            arguments = "-sT -sV"
        elif scan_type == ScanType.UDP:
            arguments = "-sU -sV"
        elif scan_type == ScanType.COMPREHENSIVE:
            arguments = "-sS -sU -sV -O -A --script=default,vuln"
        elif scan_type == ScanType.STEALTH:
            arguments = "-sS -sV -T2 --data-length 24"

        try:
            self._scanner.scan(
                target,
                ports,
                arguments=arguments,
                timeout=timeout
            )

            # Parse results
            if target in self._scanner.all_hosts():
                return self._parse_nmap_results(target)
            else:
                # Try to resolve if hostname
                try:
                    ip = socket.gethostbyname(target)
                    if ip in self._scanner.all_hosts():
                        return self._parse_nmap_results(ip)
                except socket.gaierror:
                    pass

        except nmap.PortScannerError as e:
            logger.error(f"[RECON] nmap error: {e}")
        except Exception as e:
            logger.error(f"[RECON] Scan error: {e}")

        return None

    def _parse_nmap_results(self, host: str) -> HostInfo:
        """Parse nmap scan results into HostInfo"""
        host_data = self._scanner[host]

        # Basic host info
        host_info = HostInfo(
            ip=host,
            state=host_data.state(),
            scan_time=datetime.now()
        )

        # Hostnames
        if 'hostnames' in host_data:
            for hn in host_data['hostnames']:
                if hn.get('name'):
                    host_info.hostnames.append(hn['name'])
            if host_info.hostnames:
                host_info.hostname = host_info.hostnames[0]

        # OS detection
        if 'osmatch' in host_data and host_data['osmatch']:
            best_match = host_data['osmatch'][0]
            host_info.os_match = best_match.get('name', '')
            host_info.os_accuracy = int(best_match.get('accuracy', 0))
            if 'osclass' in best_match and best_match['osclass']:
                os_class = best_match['osclass'][0]
                host_info.os_family = os_class.get('osfamily', '')
                host_info.os_gen = os_class.get('osgen', '')

        # MAC address
        if 'addresses' in host_data:
            if 'mac' in host_data['addresses']:
                host_info.mac_address = host_data['addresses']['mac']

        # Vendor
        if 'vendor' in host_data and host_info.mac_address:
            host_info.vendor = host_data['vendor'].get(host_info.mac_address, '')

        # Ports and services
        for proto in ['tcp', 'udp']:
            if proto in host_data:
                for port, port_data in host_data[proto].items():
                    port_result = PortScanResult(
                        port=port,
                        protocol=proto,
                        state=port_data.get('state', 'unknown'),
                        service=port_data.get('name', ''),
                        version=port_data.get('version', ''),
                        product=port_data.get('product', ''),
                        extra_info=port_data.get('extrainfo', ''),
                        cpe=port_data.get('cpe', '').split() if port_data.get('cpe') else []
                    )

                    # Script results
                    if 'script' in port_data:
                        port_result.scripts = dict(port_data['script'])

                    host_info.ports.append(port_result)

                    # Create service info
                    if port_data.get('state') == 'open':
                        service = ServiceInfo(
                            port=port,
                            protocol=proto,
                            name=port_data.get('name', ''),
                            product=port_data.get('product', ''),
                            version=port_data.get('version', ''),
                            extra_info=port_data.get('extrainfo', ''),
                            cpe=port_data.get('cpe', '').split() if port_data.get('cpe') else []
                        )
                        host_info.services.append(service)

        # Store results
        with self._lock:
            self._results[host] = host_info

        return host_info

    def _socket_scan(self, target: str, ports: str) -> HostInfo:
        """Fallback socket-based port scan when nmap unavailable"""
        host_info = HostInfo(ip=target, scan_time=datetime.now())

        # Parse port range
        port_list = self._parse_ports(ports)

        # Resolve hostname
        try:
            host_info.ip = socket.gethostbyname(target)
            if target != host_info.ip:
                host_info.hostname = target
                host_info.hostnames.append(target)
        except socket.gaierror:
            pass

        # Scan ports using threads
        def scan_port(port: int) -> Optional[PortScanResult]:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            try:
                result = sock.connect_ex((host_info.ip, port))
                if result == 0:
                    return PortScanResult(
                        port=port,
                        protocol='tcp',
                        state='open',
                        service=self._guess_service(port)
                    )
            except:
                pass
            finally:
                sock.close()
            return None

        with ThreadPoolExecutor(max_workers=100) as executor:
            futures = {executor.submit(scan_port, port): port for port in port_list}
            for future in as_completed(futures):
                result = future.result()
                if result:
                    host_info.ports.append(result)
                    host_info.services.append(ServiceInfo(
                        port=result.port,
                        protocol=result.protocol,
                        name=result.service
                    ))

        host_info.state = 'up' if host_info.ports else 'unknown'

        with self._lock:
            self._results[target] = host_info

        return host_info

    def _parse_ports(self, ports: str) -> List[int]:
        """Parse port specification into list"""
        result = []
        for part in ports.split(','):
            if '-' in part:
                start, end = part.split('-')
                result.extend(range(int(start), int(end) + 1))
            else:
                result.append(int(part))
        return result

    def _guess_service(self, port: int) -> str:
        """Guess service name from port number"""
        common_ports = {
            21: 'ftp', 22: 'ssh', 23: 'telnet', 25: 'smtp',
            53: 'dns', 80: 'http', 110: 'pop3', 111: 'rpcbind',
            135: 'msrpc', 139: 'netbios-ssn', 143: 'imap',
            443: 'https', 445: 'microsoft-ds', 993: 'imaps',
            995: 'pop3s', 1433: 'ms-sql-s', 1521: 'oracle',
            3306: 'mysql', 3389: 'ms-wbt-server', 5432: 'postgresql',
            5900: 'vnc', 6379: 'redis', 8080: 'http-proxy',
            8443: 'https-alt', 27017: 'mongodb'
        }
        return common_ports.get(port, 'unknown')

    def dns_enumeration(self, domain: str) -> Dict[str, List[str]]:
        """
        Perform DNS enumeration

        Args:
            domain: Target domain (must be authorized)

        Returns:
            Dictionary of DNS record types to values
        """
        if not self._verify_authorization(domain):
            return {}

        logger.info(f"[RECON] Starting DNS enumeration: {domain}")

        records = {}
        resolver = dns.resolver.Resolver()
        resolver.timeout = 5
        resolver.lifetime = 10

        for record_type in self.DNS_RECORD_TYPES:
            try:
                answers = resolver.resolve(domain, record_type)
                records[record_type] = [str(rdata) for rdata in answers]
            except dns.resolver.NoAnswer:
                pass
            except dns.resolver.NXDOMAIN:
                logger.warning(f"[RECON] Domain does not exist: {domain}")
                break
            except dns.resolver.NoNameservers:
                logger.warning(f"[RECON] No nameservers for: {domain}")
                break
            except Exception as e:
                logger.debug(f"[RECON] DNS query failed for {record_type}: {e}")

        # Try zone transfer
        try:
            ns_records = records.get('NS', [])
            for ns in ns_records:
                ns = ns.rstrip('.')
                try:
                    zone = dns.zone.from_xfr(dns.query.xfr(ns, domain, timeout=10))
                    records['AXFR'] = [str(name) for name in zone.nodes.keys()]
                    logger.warning(f"[RECON] Zone transfer successful from {ns}!")
                    break
                except Exception:
                    pass
        except Exception:
            pass

        # Reverse DNS for A records
        if 'A' in records:
            records['PTR'] = []
            for ip in records['A']:
                try:
                    rev_name = dns.reversename.from_address(ip)
                    answers = resolver.resolve(rev_name, 'PTR')
                    records['PTR'].extend([str(rdata) for rdata in answers])
                except Exception:
                    pass

        return records

    def subdomain_discovery(self, domain: str,
                           wordlist: List[str] = None,
                           threads: int = 50) -> List[str]:
        """
        Discover subdomains

        Args:
            domain: Target domain (must be authorized with wildcard *.domain)
            wordlist: Custom wordlist (uses default if None)
            threads: Number of concurrent threads

        Returns:
            List of discovered subdomains
        """
        # Check if wildcard authorized
        if not self.auth_manager.is_authorized(f"*.{domain}"):
            if not self._verify_authorization(domain):
                return []
            logger.warning(f"[RECON] Only {domain} authorized, not subdomains")
            return []

        logger.info(f"[RECON] Starting subdomain discovery: {domain}")

        wordlist = wordlist or self.SUBDOMAIN_WORDLIST
        discovered = []
        resolver = dns.resolver.Resolver()
        resolver.timeout = 3
        resolver.lifetime = 5

        def check_subdomain(prefix: str) -> Optional[str]:
            subdomain = f"{prefix}.{domain}"
            try:
                answers = resolver.resolve(subdomain, 'A')
                if answers:
                    return subdomain
            except Exception:
                pass
            return None

        with ThreadPoolExecutor(max_workers=threads) as executor:
            futures = {executor.submit(check_subdomain, prefix): prefix
                      for prefix in wordlist}
            for future in as_completed(futures):
                result = future.result()
                if result:
                    discovered.append(result)
                    logger.info(f"[RECON] Found subdomain: {result}")

        return discovered

    def detect_technologies(self, target: str, port: int = 80) -> List[str]:
        """
        Detect web technologies

        Args:
            target: Target host (must be authorized)
            port: Port to check (default 80)

        Returns:
            List of detected technologies
        """
        if not self._verify_authorization(target):
            return []

        technologies = []

        # Determine protocol
        protocol = 'https' if port in [443, 8443] else 'http'
        url = f"{protocol}://{target}:{port}"

        try:
            # Make request
            response = requests.get(
                url,
                timeout=10,
                verify=False,
                allow_redirects=True,
                headers={'User-Agent': 'Mozilla/5.0 (compatible; TSUNAMI/5.0; Security Scanner)'}
            )

            # Check headers
            headers_bytes = str(response.headers).encode()
            body_bytes = response.content

            for tech, signatures in self.TECH_SIGNATURES.items():
                for sig in signatures:
                    if sig in headers_bytes or sig in body_bytes:
                        if tech not in technologies:
                            technologies.append(tech)
                        break

            # Server header
            server = response.headers.get('Server', '')
            if server and server not in technologies:
                technologies.append(f"server:{server}")

            # X-Powered-By
            powered_by = response.headers.get('X-Powered-By', '')
            if powered_by:
                technologies.append(f"powered-by:{powered_by}")

            # Check for common CMS indicators in HTML
            html = response.text.lower()

            if 'wp-content' in html or 'wordpress' in html:
                if 'wordpress' not in technologies:
                    technologies.append('wordpress')
            if '/sites/default' in html or 'drupal' in html:
                if 'drupal' not in technologies:
                    technologies.append('drupal')
            if 'joomla' in html:
                if 'joomla' not in technologies:
                    technologies.append('joomla')
            if 'magento' in html:
                technologies.append('magento')
            if 'shopify' in html:
                technologies.append('shopify')

            # JavaScript frameworks
            if 'react' in html or 'reactdom' in html:
                technologies.append('react')
            if 'vue' in html or 'vuejs' in html:
                technologies.append('vue.js')
            if 'angular' in html:
                technologies.append('angular')
            if 'jquery' in html:
                technologies.append('jquery')

        except requests.exceptions.SSLError:
            technologies.append('ssl-error')
        except requests.exceptions.ConnectionError:
            logger.debug(f"[RECON] Connection failed to {url}")
        except Exception as e:
            logger.error(f"[RECON] Technology detection error: {e}")

        return technologies

    def comprehensive_recon(self, target: str,
                           ports: str = "1-1000",
                           scan_type: ScanType = ScanType.COMPREHENSIVE,
                           discover_subdomains: bool = True) -> Optional[HostInfo]:
        """
        Perform comprehensive reconnaissance

        Args:
            target: Target domain or IP (must be authorized)
            ports: Port range to scan
            scan_type: Type of port scan
            discover_subdomains: Whether to discover subdomains

        Returns:
            Complete HostInfo with all recon data
        """
        if not self._verify_authorization(target):
            return None

        logger.info(f"[RECON] Starting comprehensive reconnaissance: {target}")

        # Port scan
        host_info = self.scan_ports(target, ports, scan_type)
        if not host_info:
            host_info = HostInfo(ip=target)

        # DNS enumeration (if domain)
        try:
            socket.inet_aton(target)
            is_ip = True
        except socket.error:
            is_ip = False

        if not is_ip:
            host_info.dns_records = self.dns_enumeration(target)

            if discover_subdomains:
                host_info.subdomains = self.subdomain_discovery(target)

        # Technology detection for web ports
        web_ports = [p for p in host_info.ports
                    if p.port in [80, 443, 8080, 8443, 8000, 3000] and p.state == 'open']
        for port in web_ports:
            techs = self.detect_technologies(target, port.port)
            host_info.technologies.extend(techs)

        # Deduplicate technologies
        host_info.technologies = list(set(host_info.technologies))

        with self._lock:
            self._results[target] = host_info

        return host_info

    def get_results(self, target: str = None) -> Dict[str, HostInfo]:
        """Get stored scan results"""
        with self._lock:
            if target:
                return {target: self._results.get(target)} if target in self._results else {}
            return dict(self._results)

    def export_results(self, format: str = 'json') -> str:
        """Export results to specified format"""
        with self._lock:
            if format == 'json':
                return json.dumps(
                    {k: asdict(v) for k, v in self._results.items()},
                    indent=2,
                    default=str
                )
            else:
                raise ValueError(f"Unsupported format: {format}")


# Singleton instance
_recon_engine: Optional[ReconEngine] = None

def get_recon_engine() -> ReconEngine:
    """Get singleton ReconEngine instance"""
    global _recon_engine
    if _recon_engine is None:
        _recon_engine = ReconEngine()
    return _recon_engine
