#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
================================================================================
    TSUNAMI EXPLOIT DATABASE v5.0
    Exploit Database Integration Module
================================================================================

    Features:
    - Query ExploitDB API
    - Match vulnerabilities to exploits
    - Severity scoring
    - PoC availability check
    - Local exploit caching

    IMPORTANT: For authorized testing only.
================================================================================
"""

import os
import json
import logging
import hashlib
import sqlite3
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, field, asdict
from enum import Enum
from pathlib import Path
import requests
from bs4 import BeautifulSoup

from .vuln_scanner import Vulnerability, VulnSeverity

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class ExploitType(Enum):
    """Exploit types"""
    LOCAL = "local"
    REMOTE = "remote"
    WEBAPPS = "webapps"
    DOS = "dos"
    SHELLCODE = "shellcode"
    PAPERS = "papers"


class ExploitPlatform(Enum):
    """Target platforms"""
    WINDOWS = "windows"
    LINUX = "linux"
    MACOS = "macos"
    UNIX = "unix"
    FREEBSD = "freebsd"
    ANDROID = "android"
    IOS = "ios"
    HARDWARE = "hardware"
    MULTIPLE = "multiple"
    PHP = "php"
    PYTHON = "python"
    JAVA = "java"
    ASP = "asp"
    ASPX = "aspx"
    JSP = "jsp"


@dataclass
class Exploit:
    """Exploit information"""
    id: str
    title: str
    description: str
    type: ExploitType
    platform: str
    author: str
    date_published: str
    verified: bool = False
    has_poc: bool = False
    poc_code: str = ""
    cve_ids: List[str] = field(default_factory=list)
    edb_url: str = ""
    download_url: str = ""
    port: int = 0
    metasploit_module: str = ""
    tags: List[str] = field(default_factory=list)
    severity_score: float = 0.0


@dataclass
class ExploitMatch:
    """Match between vulnerability and exploit"""
    vulnerability: Vulnerability
    exploit: Exploit
    match_confidence: float  # 0.0-1.0
    match_reason: str
    attack_complexity: str  # Low, Medium, High
    privileges_required: str  # None, Low, High
    user_interaction: str  # None, Required


class ExploitDB:
    """
    Exploit Database Integration

    Searches and matches exploits from:
    - ExploitDB (exploit-db.com)
    - CVE references
    - Metasploit modules
    """

    # ExploitDB API endpoint
    EDB_SEARCH_URL = "https://www.exploit-db.com/search"

    # ExploitDB raw download base
    EDB_RAW_URL = "https://www.exploit-db.com/raw/{}"

    # Local cache directory
    CACHE_DIR = Path.home() / ".tsunami" / "exploit_cache"

    # Cache expiry (days)
    CACHE_EXPIRY = 7

    def __init__(self, use_cache: bool = True):
        self._exploits: Dict[str, Exploit] = {}
        self._matches: List[ExploitMatch] = []
        self._use_cache = use_cache

        if use_cache:
            self.CACHE_DIR.mkdir(parents=True, exist_ok=True)
            self._load_cache()

    def _load_cache(self):
        """Load cached exploits from local database"""
        cache_db = self.CACHE_DIR / "exploits.db"

        try:
            conn = sqlite3.connect(str(cache_db))
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()

            # Create table if not exists
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS exploits (
                    id TEXT PRIMARY KEY,
                    data TEXT,
                    cached_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)

            # Load recent entries
            cutoff = datetime.now() - timedelta(days=self.CACHE_EXPIRY)
            cursor.execute(
                "SELECT * FROM exploits WHERE cached_at > ?",
                (cutoff.isoformat(),)
            )

            for row in cursor.fetchall():
                exploit_data = json.loads(row['data'])
                self._exploits[row['id']] = self._dict_to_exploit(exploit_data)

            conn.close()
            logger.info(f"[EXPLOIT-DB] Loaded {len(self._exploits)} cached exploits")

        except Exception as e:
            logger.warning(f"[EXPLOIT-DB] Cache load error: {e}")

    def _save_to_cache(self, exploit: Exploit):
        """Save exploit to local cache"""
        if not self._use_cache:
            return

        cache_db = self.CACHE_DIR / "exploits.db"

        try:
            conn = sqlite3.connect(str(cache_db))
            cursor = conn.cursor()

            cursor.execute("""
                INSERT OR REPLACE INTO exploits (id, data, cached_at)
                VALUES (?, ?, ?)
            """, (exploit.id, json.dumps(asdict(exploit), default=str), datetime.now().isoformat()))

            conn.commit()
            conn.close()

        except Exception as e:
            logger.warning(f"[EXPLOIT-DB] Cache save error: {e}")

    def _dict_to_exploit(self, data: Dict) -> Exploit:
        """Convert dictionary to Exploit object"""
        return Exploit(
            id=data.get('id', ''),
            title=data.get('title', ''),
            description=data.get('description', ''),
            type=ExploitType(data.get('type', 'remote')),
            platform=data.get('platform', ''),
            author=data.get('author', ''),
            date_published=data.get('date_published', ''),
            verified=data.get('verified', False),
            has_poc=data.get('has_poc', False),
            poc_code=data.get('poc_code', ''),
            cve_ids=data.get('cve_ids', []),
            edb_url=data.get('edb_url', ''),
            download_url=data.get('download_url', ''),
            port=data.get('port', 0),
            metasploit_module=data.get('metasploit_module', ''),
            tags=data.get('tags', []),
            severity_score=data.get('severity_score', 0.0)
        )

    def search_by_cve(self, cve_id: str) -> List[Exploit]:
        """
        Search ExploitDB by CVE ID

        Args:
            cve_id: CVE identifier (e.g., CVE-2021-44228)

        Returns:
            List of matching exploits
        """
        exploits = []

        # Check cache first
        cache_key = f"cve_{cve_id}"
        if cache_key in self._exploits:
            return [self._exploits[cache_key]]

        logger.info(f"[EXPLOIT-DB] Searching for {cve_id}")

        try:
            # Search ExploitDB
            headers = {
                'User-Agent': 'TSUNAMI/5.0 Security Scanner',
                'X-Requested-With': 'XMLHttpRequest'
            }

            params = {
                'cve': cve_id.replace('CVE-', ''),
                'draw': 1,
                'columns[0][data]': 'date_published',
                'columns[1][data]': 'download',
                'columns[2][data]': 'application_md5',
                'columns[3][data]': 'verified',
                'columns[4][data]': 'description',
                'order[0][column]': 0,
                'order[0][dir]': 'desc',
                'start': 0,
                'length': 50
            }

            response = requests.get(
                self.EDB_SEARCH_URL,
                params=params,
                headers=headers,
                timeout=30
            )

            if response.status_code == 200:
                data = response.json()

                for item in data.get('data', []):
                    exploit = self._parse_edb_result(item, cve_id)
                    if exploit:
                        exploits.append(exploit)
                        self._exploits[exploit.id] = exploit
                        self._save_to_cache(exploit)

        except requests.exceptions.Timeout:
            logger.warning("[EXPLOIT-DB] Search timeout")
        except Exception as e:
            logger.error(f"[EXPLOIT-DB] Search error: {e}")

        return exploits

    def search_by_product(self, product: str, version: str = None) -> List[Exploit]:
        """
        Search ExploitDB by product name and version

        Args:
            product: Software product name
            version: Software version (optional)

        Returns:
            List of matching exploits
        """
        exploits = []
        query = f"{product} {version}" if version else product

        logger.info(f"[EXPLOIT-DB] Searching for {query}")

        try:
            headers = {
                'User-Agent': 'TSUNAMI/5.0 Security Scanner',
                'X-Requested-With': 'XMLHttpRequest'
            }

            params = {
                'q': query,
                'draw': 1,
                'columns[0][data]': 'date_published',
                'columns[1][data]': 'download',
                'columns[2][data]': 'application_md5',
                'columns[3][data]': 'verified',
                'columns[4][data]': 'description',
                'order[0][column]': 0,
                'order[0][dir]': 'desc',
                'start': 0,
                'length': 50
            }

            response = requests.get(
                self.EDB_SEARCH_URL,
                params=params,
                headers=headers,
                timeout=30
            )

            if response.status_code == 200:
                data = response.json()

                for item in data.get('data', []):
                    exploit = self._parse_edb_result(item)
                    if exploit:
                        # Filter by version if specified
                        if version and version not in exploit.title:
                            continue
                        exploits.append(exploit)
                        self._exploits[exploit.id] = exploit
                        self._save_to_cache(exploit)

        except Exception as e:
            logger.error(f"[EXPLOIT-DB] Search error: {e}")

        return exploits

    def _parse_edb_result(self, item: Dict, cve_id: str = None) -> Optional[Exploit]:
        """Parse ExploitDB search result"""
        try:
            # Extract EDB ID from download link
            download_html = item.get('download', '')
            edb_id = ""
            if 'href="' in download_html:
                # Parse href from HTML
                start = download_html.find('href="') + 6
                end = download_html.find('"', start)
                path = download_html[start:end]
                edb_id = path.split('/')[-1] if path else ""

            if not edb_id:
                return None

            # Parse verified status
            verified_html = item.get('verified', '')
            verified = 'check' in verified_html.lower()

            # Parse description
            desc_html = item.get('description', {})
            title = ""
            platform = ""

            if isinstance(desc_html, dict):
                title = desc_html.get('exploit_title', '')
                platform = desc_html.get('platform', '')
            elif isinstance(desc_html, str):
                title = desc_html

            # Determine exploit type from title
            exploit_type = ExploitType.REMOTE
            title_lower = title.lower()
            if 'local' in title_lower:
                exploit_type = ExploitType.LOCAL
            elif 'dos' in title_lower or 'denial' in title_lower:
                exploit_type = ExploitType.DOS
            elif 'webapps' in title_lower or 'web' in title_lower:
                exploit_type = ExploitType.WEBAPPS
            elif 'shellcode' in title_lower:
                exploit_type = ExploitType.SHELLCODE

            # Calculate severity score
            severity_score = self._calculate_severity(exploit_type, verified)

            exploit = Exploit(
                id=f"EDB-{edb_id}",
                title=title,
                description=title,
                type=exploit_type,
                platform=platform,
                author="",
                date_published=item.get('date_published', ''),
                verified=verified,
                has_poc=True,  # ExploitDB always has PoC
                cve_ids=[cve_id] if cve_id else [],
                edb_url=f"https://www.exploit-db.com/exploits/{edb_id}",
                download_url=self.EDB_RAW_URL.format(edb_id),
                severity_score=severity_score
            )

            return exploit

        except Exception as e:
            logger.debug(f"[EXPLOIT-DB] Parse error: {e}")
            return None

    def _calculate_severity(self, exploit_type: ExploitType, verified: bool) -> float:
        """Calculate severity score for exploit"""
        base_score = 5.0

        # Type-based scoring
        type_scores = {
            ExploitType.REMOTE: 8.0,
            ExploitType.LOCAL: 6.0,
            ExploitType.WEBAPPS: 7.5,
            ExploitType.DOS: 5.0,
            ExploitType.SHELLCODE: 8.5,
            ExploitType.PAPERS: 3.0
        }

        base_score = type_scores.get(exploit_type, 5.0)

        # Verified exploits are more reliable
        if verified:
            base_score += 1.0

        return min(base_score, 10.0)

    def download_exploit(self, exploit_id: str) -> Optional[str]:
        """
        Download exploit code

        Args:
            exploit_id: Exploit identifier (e.g., EDB-12345)

        Returns:
            Exploit code as string or None
        """
        # Check cache
        cache_file = self.CACHE_DIR / f"{exploit_id}.txt"
        if cache_file.exists():
            return cache_file.read_text()

        # Extract numeric ID
        numeric_id = exploit_id.replace('EDB-', '')

        try:
            url = self.EDB_RAW_URL.format(numeric_id)
            response = requests.get(
                url,
                headers={'User-Agent': 'TSUNAMI/5.0'},
                timeout=30
            )

            if response.status_code == 200:
                code = response.text

                # Cache the code
                cache_file.write_text(code)

                # Update exploit object
                if exploit_id in self._exploits:
                    self._exploits[exploit_id].poc_code = code

                return code

        except Exception as e:
            logger.error(f"[EXPLOIT-DB] Download error: {e}")

        return None

    def match_vulnerabilities(self, vulnerabilities: List[Vulnerability]) -> List[ExploitMatch]:
        """
        Match vulnerabilities to known exploits

        Args:
            vulnerabilities: List of discovered vulnerabilities

        Returns:
            List of exploit matches
        """
        matches = []

        for vuln in vulnerabilities:
            # Search by CVE ID
            if vuln.id.startswith('CVE-'):
                exploits = self.search_by_cve(vuln.id)
                for exploit in exploits:
                    match = ExploitMatch(
                        vulnerability=vuln,
                        exploit=exploit,
                        match_confidence=0.95,  # Direct CVE match
                        match_reason=f"CVE match: {vuln.id}",
                        attack_complexity=self._estimate_complexity(exploit),
                        privileges_required=self._estimate_privileges(exploit),
                        user_interaction=self._estimate_interaction(exploit)
                    )
                    matches.append(match)

            # Search by affected component
            if vuln.affected_component:
                product = vuln.affected_component.split()[0]
                version = vuln.affected_component.split()[1] if len(vuln.affected_component.split()) > 1 else None

                exploits = self.search_by_product(product, version)
                for exploit in exploits:
                    # Calculate confidence based on title match
                    confidence = self._calculate_match_confidence(vuln, exploit)
                    if confidence > 0.5:
                        match = ExploitMatch(
                            vulnerability=vuln,
                            exploit=exploit,
                            match_confidence=confidence,
                            match_reason=f"Product match: {product}",
                            attack_complexity=self._estimate_complexity(exploit),
                            privileges_required=self._estimate_privileges(exploit),
                            user_interaction=self._estimate_interaction(exploit)
                        )
                        matches.append(match)

        self._matches = matches
        return matches

    def _calculate_match_confidence(self, vuln: Vulnerability, exploit: Exploit) -> float:
        """Calculate confidence score for vulnerability-exploit match"""
        confidence = 0.5

        # CVE match
        if vuln.id in exploit.cve_ids:
            confidence += 0.4

        # Version in title
        if vuln.affected_versions:
            for version in vuln.affected_versions:
                if version in exploit.title:
                    confidence += 0.2
                    break

        # Product name match
        if vuln.affected_component:
            product = vuln.affected_component.split()[0].lower()
            if product in exploit.title.lower():
                confidence += 0.1

        return min(confidence, 1.0)

    def _estimate_complexity(self, exploit: Exploit) -> str:
        """Estimate attack complexity"""
        # Based on exploit type
        if exploit.type in [ExploitType.REMOTE, ExploitType.WEBAPPS]:
            return "Low"
        elif exploit.type == ExploitType.LOCAL:
            return "Medium"
        elif exploit.type == ExploitType.SHELLCODE:
            return "High"
        return "Medium"

    def _estimate_privileges(self, exploit: Exploit) -> str:
        """Estimate required privileges"""
        title_lower = exploit.title.lower()

        if 'authenticated' in title_lower or 'auth' in title_lower:
            return "Low"
        if 'admin' in title_lower or 'root' in title_lower:
            return "High"
        if exploit.type == ExploitType.LOCAL:
            return "Low"
        return "None"

    def _estimate_interaction(self, exploit: Exploit) -> str:
        """Estimate user interaction requirement"""
        title_lower = exploit.title.lower()

        if 'xss' in title_lower or 'csrf' in title_lower or 'clickjack' in title_lower:
            return "Required"
        if exploit.type == ExploitType.WEBAPPS:
            return "Required"
        return "None"

    def get_high_severity_exploits(self, min_score: float = 7.0) -> List[Exploit]:
        """Get exploits above severity threshold"""
        return [e for e in self._exploits.values() if e.severity_score >= min_score]

    def get_verified_exploits(self) -> List[Exploit]:
        """Get only verified exploits"""
        return [e for e in self._exploits.values() if e.verified]

    def get_matches_by_severity(self, min_severity: VulnSeverity = VulnSeverity.HIGH) -> List[ExploitMatch]:
        """Get matches filtered by vulnerability severity"""
        severity_order = [
            VulnSeverity.CRITICAL,
            VulnSeverity.HIGH,
            VulnSeverity.MEDIUM,
            VulnSeverity.LOW,
            VulnSeverity.INFO
        ]

        min_index = severity_order.index(min_severity)
        allowed_severities = severity_order[:min_index + 1]

        return [m for m in self._matches if m.vulnerability.severity in allowed_severities]

    def export_results(self, format: str = 'json') -> str:
        """Export results"""
        if format == 'json':
            return json.dumps({
                'exploits': {k: asdict(v) for k, v in self._exploits.items()},
                'matches': [
                    {
                        'vulnerability_id': m.vulnerability.id,
                        'exploit_id': m.exploit.id,
                        'confidence': m.match_confidence,
                        'reason': m.match_reason,
                        'attack_complexity': m.attack_complexity,
                        'privileges_required': m.privileges_required,
                        'user_interaction': m.user_interaction
                    }
                    for m in self._matches
                ]
            }, indent=2, default=str)
        raise ValueError(f"Unsupported format: {format}")


# Singleton instance
_exploit_db: Optional[ExploitDB] = None

def get_exploit_db() -> ExploitDB:
    """Get singleton ExploitDB instance"""
    global _exploit_db
    if _exploit_db is None:
        _exploit_db = ExploitDB()
    return _exploit_db
