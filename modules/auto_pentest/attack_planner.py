#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
================================================================================
    TSUNAMI ATTACK PLANNER v5.0
    AI-Driven Attack Planning Module
================================================================================

    Features:
    - Analyze recon results
    - Prioritize attack vectors
    - Generate attack tree
    - Estimate success probability
    - Suggest attack sequence
    - MITRE ATT&CK mapping

    IMPORTANT: For authorized testing only.
================================================================================
"""

import json
import logging
import hashlib
from datetime import datetime
from typing import Dict, List, Optional, Set, Tuple, Any
from dataclasses import dataclass, field, asdict
from enum import Enum
import math

from .recon_engine import HostInfo, ServiceInfo, PortScanResult
from .vuln_scanner import Vulnerability, VulnSeverity
from .exploit_db import Exploit, ExploitMatch

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class AttackPhase(Enum):
    """MITRE ATT&CK Kill Chain phases"""
    RECONNAISSANCE = "reconnaissance"
    RESOURCE_DEVELOPMENT = "resource_development"
    INITIAL_ACCESS = "initial_access"
    EXECUTION = "execution"
    PERSISTENCE = "persistence"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    DEFENSE_EVASION = "defense_evasion"
    CREDENTIAL_ACCESS = "credential_access"
    DISCOVERY = "discovery"
    LATERAL_MOVEMENT = "lateral_movement"
    COLLECTION = "collection"
    COMMAND_AND_CONTROL = "command_and_control"
    EXFILTRATION = "exfiltration"
    IMPACT = "impact"


class AttackDifficulty(Enum):
    """Attack difficulty levels"""
    TRIVIAL = "trivial"      # Script kiddie level
    EASY = "easy"            # Basic skills needed
    MODERATE = "moderate"    # Experienced attacker
    HARD = "hard"            # Expert level
    EXPERT = "expert"        # APT level


@dataclass
class AttackVector:
    """Single attack vector"""
    id: str
    name: str
    description: str
    phase: AttackPhase
    difficulty: AttackDifficulty
    success_probability: float  # 0.0-1.0
    impact_score: float  # 0.0-10.0
    prerequisites: List[str] = field(default_factory=list)
    target_service: str = ""
    target_port: int = 0
    vulnerability: Optional[Vulnerability] = None
    exploit: Optional[Exploit] = None
    mitre_technique: str = ""
    mitre_tactic: str = ""
    estimated_time: int = 0  # minutes
    tools_required: List[str] = field(default_factory=list)
    detection_risk: str = "medium"  # low, medium, high
    notes: str = ""


@dataclass
class AttackTreeNode:
    """Node in attack tree"""
    id: str
    vector: AttackVector
    children: List['AttackTreeNode'] = field(default_factory=list)
    parent_id: Optional[str] = None
    is_root: bool = False
    cumulative_probability: float = 0.0
    cumulative_time: int = 0


@dataclass
class AttackTree:
    """Complete attack tree"""
    root: AttackTreeNode
    all_paths: List[List[AttackVector]] = field(default_factory=list)
    recommended_path: List[AttackVector] = field(default_factory=list)
    total_vectors: int = 0
    max_success_probability: float = 0.0
    estimated_total_time: int = 0


@dataclass
class AttackPlan:
    """Complete attack plan"""
    target: str
    created_at: datetime = field(default_factory=datetime.now)
    attack_tree: Optional[AttackTree] = None
    vectors: List[AttackVector] = field(default_factory=list)
    recommended_sequence: List[AttackVector] = field(default_factory=list)
    risk_assessment: Dict[str, Any] = field(default_factory=dict)
    mitre_mapping: Dict[str, List[str]] = field(default_factory=dict)
    executive_summary: str = ""


class AttackPlanner:
    """
    AI-Driven Attack Planner

    Analyzes reconnaissance results and vulnerability data
    to create prioritized attack plans.
    """

    # MITRE ATT&CK technique mappings
    MITRE_TECHNIQUES = {
        'ssh': ['T1021.004', 'T1110.001', 'T1110.003'],  # Remote Services, Brute Force
        'ftp': ['T1071.002', 'T1110.001'],  # Application Layer Protocol, Brute Force
        'http': ['T1190', 'T1059.007', 'T1203'],  # Exploit Public-Facing, JavaScript, Client Execution
        'https': ['T1190', 'T1059.007', 'T1573'],  # + Encrypted Channel
        'smb': ['T1021.002', 'T1570', 'T1187'],  # SMB, Lateral Tool Transfer, LLMNR/NBT-NS
        'rdp': ['T1021.001', 'T1110.001'],  # Remote Desktop, Brute Force
        'mysql': ['T1190', 'T1078'],  # Exploit App, Valid Accounts
        'mssql': ['T1190', 'T1078', 'T1059.001'],  # + PowerShell via xp_cmdshell
        'postgresql': ['T1190', 'T1078'],
        'mongodb': ['T1190', 'T1078'],
        'redis': ['T1190', 'T1059'],
        'telnet': ['T1021.004', 'T1110'],
        'ldap': ['T1087.002', 'T1069.002'],  # Account Discovery, Permission Groups
        'dns': ['T1071.004', 'T1048.003'],  # DNS Protocol, Exfil Over DNS
        'smtp': ['T1071.003', 'T1566'],  # Email Protocol, Phishing
    }

    # Service-based attack templates
    ATTACK_TEMPLATES = {
        'ssh': [
            {
                'name': 'SSH Brute Force',
                'phase': AttackPhase.INITIAL_ACCESS,
                'difficulty': AttackDifficulty.EASY,
                'base_probability': 0.3,
                'tools': ['hydra', 'medusa', 'ncrack'],
                'time': 30,
                'detection': 'high'
            },
            {
                'name': 'SSH Version Exploit',
                'phase': AttackPhase.INITIAL_ACCESS,
                'difficulty': AttackDifficulty.MODERATE,
                'base_probability': 0.5,
                'tools': ['metasploit', 'exploit-db'],
                'time': 15,
                'detection': 'medium'
            },
            {
                'name': 'SSH Key Theft',
                'phase': AttackPhase.CREDENTIAL_ACCESS,
                'difficulty': AttackDifficulty.HARD,
                'base_probability': 0.2,
                'tools': ['custom'],
                'time': 60,
                'detection': 'low'
            }
        ],
        'http': [
            {
                'name': 'Web Application Scan',
                'phase': AttackPhase.RECONNAISSANCE,
                'difficulty': AttackDifficulty.TRIVIAL,
                'base_probability': 0.9,
                'tools': ['nikto', 'gobuster', 'wfuzz'],
                'time': 20,
                'detection': 'high'
            },
            {
                'name': 'SQL Injection',
                'phase': AttackPhase.INITIAL_ACCESS,
                'difficulty': AttackDifficulty.MODERATE,
                'base_probability': 0.4,
                'tools': ['sqlmap', 'burp'],
                'time': 45,
                'detection': 'medium'
            },
            {
                'name': 'File Upload Exploit',
                'phase': AttackPhase.EXECUTION,
                'difficulty': AttackDifficulty.MODERATE,
                'base_probability': 0.35,
                'tools': ['burp', 'custom'],
                'time': 30,
                'detection': 'medium'
            },
            {
                'name': 'XSS to Session Hijack',
                'phase': AttackPhase.CREDENTIAL_ACCESS,
                'difficulty': AttackDifficulty.MODERATE,
                'base_probability': 0.45,
                'tools': ['beef', 'xsshunter'],
                'time': 40,
                'detection': 'low'
            },
        ],
        'smb': [
            {
                'name': 'SMB Enumeration',
                'phase': AttackPhase.DISCOVERY,
                'difficulty': AttackDifficulty.TRIVIAL,
                'base_probability': 0.85,
                'tools': ['enum4linux', 'smbclient'],
                'time': 10,
                'detection': 'medium'
            },
            {
                'name': 'EternalBlue (MS17-010)',
                'phase': AttackPhase.INITIAL_ACCESS,
                'difficulty': AttackDifficulty.EASY,
                'base_probability': 0.7,  # If vulnerable
                'tools': ['metasploit', 'eternal_scanner'],
                'time': 5,
                'detection': 'high'
            },
            {
                'name': 'SMB Relay Attack',
                'phase': AttackPhase.CREDENTIAL_ACCESS,
                'difficulty': AttackDifficulty.MODERATE,
                'base_probability': 0.5,
                'tools': ['responder', 'ntlmrelayx'],
                'time': 60,
                'detection': 'medium'
            }
        ],
        'mysql': [
            {
                'name': 'MySQL Brute Force',
                'phase': AttackPhase.INITIAL_ACCESS,
                'difficulty': AttackDifficulty.EASY,
                'base_probability': 0.25,
                'tools': ['hydra', 'medusa'],
                'time': 30,
                'detection': 'high'
            },
            {
                'name': 'MySQL UDF Exploit',
                'phase': AttackPhase.EXECUTION,
                'difficulty': AttackDifficulty.HARD,
                'base_probability': 0.3,
                'tools': ['metasploit', 'custom'],
                'time': 45,
                'detection': 'medium'
            }
        ],
        'redis': [
            {
                'name': 'Redis Unauthenticated Access',
                'phase': AttackPhase.INITIAL_ACCESS,
                'difficulty': AttackDifficulty.TRIVIAL,
                'base_probability': 0.8,
                'tools': ['redis-cli'],
                'time': 5,
                'detection': 'low'
            },
            {
                'name': 'Redis SSH Key Injection',
                'phase': AttackPhase.PERSISTENCE,
                'difficulty': AttackDifficulty.EASY,
                'base_probability': 0.7,
                'tools': ['redis-cli'],
                'time': 10,
                'detection': 'medium'
            }
        ],
        'rdp': [
            {
                'name': 'RDP Brute Force',
                'phase': AttackPhase.INITIAL_ACCESS,
                'difficulty': AttackDifficulty.EASY,
                'base_probability': 0.2,
                'tools': ['crowbar', 'hydra'],
                'time': 60,
                'detection': 'high'
            },
            {
                'name': 'BlueKeep (CVE-2019-0708)',
                'phase': AttackPhase.INITIAL_ACCESS,
                'difficulty': AttackDifficulty.MODERATE,
                'base_probability': 0.6,  # If vulnerable
                'tools': ['metasploit'],
                'time': 10,
                'detection': 'high'
            }
        ]
    }

    def __init__(self):
        self._attack_plans: Dict[str, AttackPlan] = {}
        self._vector_id_counter = 0

    def _generate_vector_id(self) -> str:
        """Generate unique vector ID"""
        self._vector_id_counter += 1
        return f"AV-{self._vector_id_counter:04d}"

    def analyze_host(self, host_info: HostInfo,
                    vulnerabilities: List[Vulnerability] = None,
                    exploit_matches: List[ExploitMatch] = None) -> AttackPlan:
        """
        Analyze host and create attack plan

        Args:
            host_info: Reconnaissance results
            vulnerabilities: Discovered vulnerabilities
            exploit_matches: Matched exploits

        Returns:
            Complete attack plan
        """
        logger.info(f"[ATTACK-PLANNER] Analyzing {host_info.ip}")

        plan = AttackPlan(target=host_info.ip)
        vectors = []

        # Generate attack vectors from services
        for service in host_info.services:
            service_vectors = self._generate_service_vectors(service, host_info)
            vectors.extend(service_vectors)

        # Generate vectors from vulnerabilities
        if vulnerabilities:
            vuln_vectors = self._generate_vuln_vectors(vulnerabilities)
            vectors.extend(vuln_vectors)

        # Enhance vectors with exploit information
        if exploit_matches:
            self._enhance_with_exploits(vectors, exploit_matches)

        # Calculate success probabilities
        self._calculate_probabilities(vectors, host_info)

        # Generate MITRE ATT&CK mapping
        plan.mitre_mapping = self._generate_mitre_mapping(vectors)

        # Build attack tree
        plan.attack_tree = self._build_attack_tree(vectors)

        # Determine recommended sequence
        plan.recommended_sequence = self._get_optimal_sequence(vectors)

        # Generate risk assessment
        plan.risk_assessment = self._assess_risk(vectors, host_info)

        # Generate executive summary
        plan.executive_summary = self._generate_summary(plan)

        plan.vectors = vectors

        # Store plan
        self._attack_plans[host_info.ip] = plan

        return plan

    def _generate_service_vectors(self, service: ServiceInfo,
                                  host_info: HostInfo) -> List[AttackVector]:
        """Generate attack vectors for a service"""
        vectors = []
        service_name = service.name.lower()

        # Map common service names
        service_map = {
            'microsoft-ds': 'smb',
            'netbios-ssn': 'smb',
            'ms-sql-s': 'mssql',
            'ms-wbt-server': 'rdp',
            'domain': 'dns',
            'http-proxy': 'http'
        }
        service_name = service_map.get(service_name, service_name)

        # Get templates for this service
        templates = self.ATTACK_TEMPLATES.get(service_name, [])

        for template in templates:
            vector = AttackVector(
                id=self._generate_vector_id(),
                name=template['name'],
                description=f"{template['name']} against {service.name} on port {service.port}",
                phase=template['phase'],
                difficulty=template['difficulty'],
                success_probability=template['base_probability'],
                impact_score=self._estimate_impact(template['phase']),
                target_service=service.name,
                target_port=service.port,
                mitre_technique=self._get_mitre_technique(service_name),
                mitre_tactic=template['phase'].value,
                estimated_time=template['time'],
                tools_required=template['tools'],
                detection_risk=template['detection']
            )
            vectors.append(vector)

        return vectors

    def _generate_vuln_vectors(self, vulnerabilities: List[Vulnerability]) -> List[AttackVector]:
        """Generate attack vectors from vulnerabilities"""
        vectors = []

        for vuln in vulnerabilities:
            # Skip info-level vulns
            if vuln.severity == VulnSeverity.INFO:
                continue

            # Determine attack phase based on vulnerability type
            phase = AttackPhase.INITIAL_ACCESS
            if 'privilege' in vuln.title.lower() or 'escalat' in vuln.title.lower():
                phase = AttackPhase.PRIVILEGE_ESCALATION
            elif 'inject' in vuln.title.lower() or 'xss' in vuln.title.lower():
                phase = AttackPhase.EXECUTION
            elif 'credential' in vuln.title.lower() or 'password' in vuln.title.lower():
                phase = AttackPhase.CREDENTIAL_ACCESS

            # Estimate difficulty from CVSS
            difficulty = AttackDifficulty.MODERATE
            if vuln.cvss_score >= 9.0:
                difficulty = AttackDifficulty.EASY
            elif vuln.cvss_score >= 7.0:
                difficulty = AttackDifficulty.MODERATE
            elif vuln.cvss_score >= 4.0:
                difficulty = AttackDifficulty.HARD

            # Estimate success probability
            probability = min(vuln.cvss_score / 10.0, 0.9)
            if vuln.exploit_available:
                probability = min(probability + 0.2, 0.95)

            vector = AttackVector(
                id=self._generate_vector_id(),
                name=f"Exploit {vuln.id}",
                description=vuln.description[:200] if vuln.description else vuln.title,
                phase=phase,
                difficulty=difficulty,
                success_probability=probability,
                impact_score=vuln.cvss_score,
                vulnerability=vuln,
                mitre_technique=vuln.cwe_id if vuln.cwe_id else "",
                estimated_time=self._estimate_exploit_time(vuln),
                detection_risk="medium" if vuln.cvss_score < 7.0 else "high"
            )
            vectors.append(vector)

        return vectors

    def _enhance_with_exploits(self, vectors: List[AttackVector],
                               exploit_matches: List[ExploitMatch]):
        """Enhance vectors with exploit information"""
        for match in exploit_matches:
            # Find matching vector
            for vector in vectors:
                if vector.vulnerability and vector.vulnerability.id == match.vulnerability.id:
                    vector.exploit = match.exploit
                    # Increase probability if exploit is verified
                    if match.exploit.verified:
                        vector.success_probability = min(
                            vector.success_probability + 0.15, 0.95)
                    vector.tools_required.append(f"ExploitDB: {match.exploit.id}")
                    break

    def _calculate_probabilities(self, vectors: List[AttackVector],
                                host_info: HostInfo):
        """Calculate and adjust success probabilities"""
        for vector in vectors:
            # Adjust based on host OS
            if host_info.os_match:
                os_lower = host_info.os_match.lower()
                if 'linux' in os_lower:
                    if 'ssh' in vector.target_service:
                        vector.success_probability *= 0.9  # SSH usually well configured
                elif 'windows' in os_lower:
                    if 'smb' in vector.target_service:
                        vector.success_probability *= 1.1  # SMB often vulnerable

            # Cap probability
            vector.success_probability = min(vector.success_probability, 0.95)

    def _estimate_impact(self, phase: AttackPhase) -> float:
        """Estimate impact score for attack phase"""
        impact_map = {
            AttackPhase.RECONNAISSANCE: 2.0,
            AttackPhase.RESOURCE_DEVELOPMENT: 3.0,
            AttackPhase.INITIAL_ACCESS: 8.0,
            AttackPhase.EXECUTION: 8.5,
            AttackPhase.PERSISTENCE: 7.0,
            AttackPhase.PRIVILEGE_ESCALATION: 9.0,
            AttackPhase.DEFENSE_EVASION: 6.0,
            AttackPhase.CREDENTIAL_ACCESS: 8.0,
            AttackPhase.DISCOVERY: 4.0,
            AttackPhase.LATERAL_MOVEMENT: 7.5,
            AttackPhase.COLLECTION: 6.5,
            AttackPhase.COMMAND_AND_CONTROL: 7.0,
            AttackPhase.EXFILTRATION: 9.5,
            AttackPhase.IMPACT: 10.0
        }
        return impact_map.get(phase, 5.0)

    def _estimate_exploit_time(self, vuln: Vulnerability) -> int:
        """Estimate time to exploit vulnerability (minutes)"""
        base_time = 30

        # Adjust based on CVSS (easier vulns = less time)
        if vuln.cvss_score >= 9.0:
            base_time = 10
        elif vuln.cvss_score >= 7.0:
            base_time = 20
        elif vuln.cvss_score >= 4.0:
            base_time = 45

        if vuln.exploit_available:
            base_time = int(base_time * 0.5)

        return base_time

    def _get_mitre_technique(self, service: str) -> str:
        """Get MITRE technique for service"""
        techniques = self.MITRE_TECHNIQUES.get(service, [])
        return techniques[0] if techniques else ""

    def _generate_mitre_mapping(self, vectors: List[AttackVector]) -> Dict[str, List[str]]:
        """Generate MITRE ATT&CK mapping"""
        mapping = {}

        for vector in vectors:
            tactic = vector.phase.value
            if tactic not in mapping:
                mapping[tactic] = []

            if vector.mitre_technique and vector.mitre_technique not in mapping[tactic]:
                mapping[tactic].append(vector.mitre_technique)

        return mapping

    def _build_attack_tree(self, vectors: List[AttackVector]) -> AttackTree:
        """Build attack tree from vectors"""
        if not vectors:
            return None

        # Sort by phase order
        phase_order = list(AttackPhase)
        vectors_sorted = sorted(vectors,
                               key=lambda v: phase_order.index(v.phase))

        # Create root node (first recon or initial access vector)
        root_vectors = [v for v in vectors_sorted
                       if v.phase in [AttackPhase.RECONNAISSANCE, AttackPhase.INITIAL_ACCESS]]

        if not root_vectors:
            root_vectors = [vectors_sorted[0]]

        # Build tree
        root = AttackTreeNode(
            id="ROOT",
            vector=root_vectors[0],
            is_root=True,
            cumulative_probability=root_vectors[0].success_probability,
            cumulative_time=root_vectors[0].estimated_time
        )

        # Add children based on phase progression
        current_nodes = [root]
        processed = {root_vectors[0].id}

        for phase in phase_order:
            phase_vectors = [v for v in vectors_sorted
                           if v.phase == phase and v.id not in processed]

            for vector in phase_vectors:
                node = AttackTreeNode(
                    id=vector.id,
                    vector=vector,
                    cumulative_probability=current_nodes[-1].cumulative_probability * vector.success_probability,
                    cumulative_time=current_nodes[-1].cumulative_time + vector.estimated_time
                )

                if current_nodes:
                    node.parent_id = current_nodes[-1].id
                    current_nodes[-1].children.append(node)

                current_nodes.append(node)
                processed.add(vector.id)

        # Generate all paths
        all_paths = self._generate_paths(root)

        # Find recommended path (highest probability * impact)
        recommended = max(all_paths,
                         key=lambda path: sum(v.success_probability * v.impact_score for v in path),
                         default=[])

        return AttackTree(
            root=root,
            all_paths=all_paths,
            recommended_path=recommended,
            total_vectors=len(vectors),
            max_success_probability=max(v.success_probability for v in vectors) if vectors else 0,
            estimated_total_time=sum(v.estimated_time for v in recommended)
        )

    def _generate_paths(self, node: AttackTreeNode,
                       current_path: List[AttackVector] = None) -> List[List[AttackVector]]:
        """Generate all paths in attack tree"""
        if current_path is None:
            current_path = []

        current_path = current_path + [node.vector]

        if not node.children:
            return [current_path]

        paths = []
        for child in node.children:
            child_paths = self._generate_paths(child, current_path)
            paths.extend(child_paths)

        return paths

    def _get_optimal_sequence(self, vectors: List[AttackVector]) -> List[AttackVector]:
        """Get optimal attack sequence"""
        if not vectors:
            return []

        # Score vectors: probability * impact / time
        scored = [(v, v.success_probability * v.impact_score / max(v.estimated_time, 1))
                 for v in vectors]

        # Sort by score descending
        scored.sort(key=lambda x: x[1], reverse=True)

        # Return top vectors maintaining phase order
        top_vectors = [v for v, _ in scored[:10]]

        phase_order = list(AttackPhase)
        return sorted(top_vectors, key=lambda v: phase_order.index(v.phase))

    def _assess_risk(self, vectors: List[AttackVector],
                    host_info: HostInfo) -> Dict[str, Any]:
        """Assess overall risk"""
        if not vectors:
            return {'level': 'low', 'score': 0}

        # Calculate risk metrics
        max_impact = max(v.impact_score for v in vectors)
        avg_probability = sum(v.success_probability for v in vectors) / len(vectors)
        high_risk_count = len([v for v in vectors if v.success_probability > 0.7])

        # Risk score
        risk_score = (max_impact * 0.4 + avg_probability * 10 * 0.3 +
                     min(high_risk_count * 2, 10) * 0.3)

        # Risk level
        if risk_score >= 8.0:
            level = 'critical'
        elif risk_score >= 6.0:
            level = 'high'
        elif risk_score >= 4.0:
            level = 'medium'
        else:
            level = 'low'

        return {
            'level': level,
            'score': round(risk_score, 2),
            'max_impact': max_impact,
            'avg_probability': round(avg_probability, 2),
            'high_risk_vectors': high_risk_count,
            'total_vectors': len(vectors),
            'critical_services': [s.name for s in host_info.services
                                 if s.port in [22, 3389, 445, 3306, 5432]]
        }

    def _generate_summary(self, plan: AttackPlan) -> str:
        """Generate executive summary"""
        risk = plan.risk_assessment
        vectors = plan.vectors

        summary_parts = [
            f"Target Assessment: {plan.target}",
            f"Risk Level: {risk.get('level', 'unknown').upper()}",
            f"Risk Score: {risk.get('score', 0)}/10",
            "",
            f"Total Attack Vectors: {len(vectors)}",
            f"High-Risk Vectors: {risk.get('high_risk_vectors', 0)}",
        ]

        if plan.recommended_sequence:
            summary_parts.extend([
                "",
                "Recommended Attack Path:",
            ])
            for i, v in enumerate(plan.recommended_sequence[:5], 1):
                summary_parts.append(f"  {i}. {v.name} ({v.phase.value}) - {v.success_probability:.0%} success")

        if risk.get('critical_services'):
            summary_parts.extend([
                "",
                f"Critical Services Exposed: {', '.join(risk['critical_services'])}"
            ])

        return "\n".join(summary_parts)

    def get_plan(self, target: str) -> Optional[AttackPlan]:
        """Get attack plan for target"""
        return self._attack_plans.get(target)

    def export_plan(self, target: str, format: str = 'json') -> str:
        """Export attack plan"""
        plan = self._attack_plans.get(target)
        if not plan:
            return "{}"

        if format == 'json':
            return json.dumps({
                'target': plan.target,
                'created_at': plan.created_at.isoformat(),
                'executive_summary': plan.executive_summary,
                'risk_assessment': plan.risk_assessment,
                'mitre_mapping': plan.mitre_mapping,
                'vectors': [
                    {
                        'id': v.id,
                        'name': v.name,
                        'description': v.description,
                        'phase': v.phase.value,
                        'difficulty': v.difficulty.value,
                        'success_probability': v.success_probability,
                        'impact_score': v.impact_score,
                        'target_service': v.target_service,
                        'target_port': v.target_port,
                        'mitre_technique': v.mitre_technique,
                        'estimated_time': v.estimated_time,
                        'tools_required': v.tools_required,
                        'detection_risk': v.detection_risk
                    }
                    for v in plan.vectors
                ],
                'recommended_sequence': [v.id for v in plan.recommended_sequence]
            }, indent=2)

        raise ValueError(f"Unsupported format: {format}")


# Singleton instance
_attack_planner: Optional[AttackPlanner] = None

def get_attack_planner() -> AttackPlanner:
    """Get singleton AttackPlanner instance"""
    global _attack_planner
    if _attack_planner is None:
        _attack_planner = AttackPlanner()
    return _attack_planner
