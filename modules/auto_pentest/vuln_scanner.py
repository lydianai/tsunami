#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
================================================================================
    TSUNAMI VULNERABILITY SCANNER v5.0
    Automated Vulnerability Detection Module
================================================================================

    Features:
    - CVE lookup for detected services
    - Version-based vulnerability matching
    - Configuration checks
    - SSL/TLS analysis
    - Header security checks
    - Common misconfigurations

    IMPORTANT: For authorized testing only.
================================================================================
"""

import ssl
import socket
import json
import logging
import re
import hashlib
from datetime import datetime
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, field, asdict
from enum import Enum
from concurrent.futures import ThreadPoolExecutor, as_completed
import requests

from .recon_engine import HostInfo, ServiceInfo, PortScanResult

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class VulnSeverity(Enum):
    """Vulnerability severity levels (CVSS based)"""
    CRITICAL = "critical"  # 9.0-10.0
    HIGH = "high"          # 7.0-8.9
    MEDIUM = "medium"      # 4.0-6.9
    LOW = "low"            # 1.0-3.9
    INFO = "info"          # 0.0-0.9

    @staticmethod
    def from_cvss(score: float) -> 'VulnSeverity':
        """Convert CVSS score to severity"""
        if score >= 9.0:
            return VulnSeverity.CRITICAL
        elif score >= 7.0:
            return VulnSeverity.HIGH
        elif score >= 4.0:
            return VulnSeverity.MEDIUM
        elif score >= 1.0:
            return VulnSeverity.LOW
        return VulnSeverity.INFO


@dataclass
class Vulnerability:
    """Vulnerability information"""
    id: str  # CVE-YYYY-NNNNN or custom ID
    title: str
    description: str
    severity: VulnSeverity
    cvss_score: float = 0.0
    cvss_vector: str = ""
    affected_component: str = ""
    affected_versions: List[str] = field(default_factory=list)
    references: List[str] = field(default_factory=list)
    cwe_id: str = ""
    remediation: str = ""
    exploit_available: bool = False
    discovered_at: datetime = field(default_factory=datetime.now)
    evidence: Dict[str, Any] = field(default_factory=dict)


@dataclass
class SSLFinding:
    """SSL/TLS analysis finding"""
    issue: str
    severity: VulnSeverity
    details: str
    recommendation: str


@dataclass
class HeaderFinding:
    """HTTP header security finding"""
    header: str
    issue: str
    severity: VulnSeverity
    current_value: str
    recommended_value: str


class VulnScanner:
    """
    Vulnerability Scanner

    Performs vulnerability assessment including:
    - CVE lookup for detected services
    - SSL/TLS configuration analysis
    - HTTP security headers check
    - Common misconfiguration detection
    """

    # Known vulnerable service versions (sample database)
    # In production, integrate with NVD/CVE databases
    VULN_DATABASE = {
        # SSH
        'openssh': {
            '7.2': [('CVE-2016-3115', 7.5, 'X11 forwarding vulnerability')],
            '7.4': [('CVE-2017-15906', 5.3, 'Read-only bypass')],
            '8.2': [('CVE-2020-14145', 5.9, 'Observable timing discrepancy')],
        },
        # Apache
        'apache': {
            '2.4.49': [('CVE-2021-41773', 9.8, 'Path traversal and RCE')],
            '2.4.50': [('CVE-2021-42013', 9.8, 'Path traversal bypass')],
        },
        # Nginx
        'nginx': {
            '1.16.1': [('CVE-2019-20372', 5.3, 'HTTP request smuggling')],
        },
        # MySQL
        'mysql': {
            '5.7.30': [('CVE-2020-14812', 4.9, 'Server optimization vulnerability')],
            '8.0.20': [('CVE-2020-14765', 6.5, 'Server FTS vulnerability')],
        },
        # PostgreSQL
        'postgresql': {
            '12.2': [('CVE-2020-10733', 7.5, 'Windows installer vulnerability')],
        },
        # Redis
        'redis': {
            '5.0.7': [('CVE-2020-14147', 7.5, 'Integer overflow')],
        },
        # ProFTPD
        'proftpd': {
            '1.3.5': [('CVE-2015-3306', 10.0, 'mod_copy arbitrary file copy')],
        },
        # vsftpd
        'vsftpd': {
            '2.3.4': [('CVE-2011-2523', 9.8, 'Backdoor command execution')],
        },
        # Samba
        'samba': {
            '4.5.9': [('CVE-2017-7494', 9.8, 'SambaCry RCE')],
        },
        # Microsoft IIS
        'microsoft-iis': {
            '10.0': [('CVE-2021-31166', 9.8, 'HTTP Protocol Stack RCE')],
        },
    }

    # Weak SSL/TLS configurations
    WEAK_SSL_CONFIGS = {
        'sslv2': ('SSLv2 enabled', VulnSeverity.CRITICAL, 'Disable SSLv2'),
        'sslv3': ('SSLv3 enabled (POODLE vulnerable)', VulnSeverity.HIGH, 'Disable SSLv3'),
        'tlsv1.0': ('TLS 1.0 enabled', VulnSeverity.MEDIUM, 'Upgrade to TLS 1.2+'),
        'tlsv1.1': ('TLS 1.1 enabled', VulnSeverity.LOW, 'Upgrade to TLS 1.2+'),
    }

    # Weak cipher suites
    WEAK_CIPHERS = [
        'RC4', 'DES', '3DES', 'MD5', 'NULL', 'EXPORT', 'anon', 'RC2'
    ]

    # Required security headers
    SECURITY_HEADERS = {
        'Strict-Transport-Security': {
            'required': True,
            'severity': VulnSeverity.MEDIUM,
            'recommended': 'max-age=31536000; includeSubDomains',
            'description': 'Missing HSTS header - vulnerable to downgrade attacks'
        },
        'X-Content-Type-Options': {
            'required': True,
            'severity': VulnSeverity.LOW,
            'recommended': 'nosniff',
            'description': 'Missing X-Content-Type-Options - MIME sniffing possible'
        },
        'X-Frame-Options': {
            'required': True,
            'severity': VulnSeverity.MEDIUM,
            'recommended': 'DENY',
            'description': 'Missing X-Frame-Options - clickjacking vulnerable'
        },
        'X-XSS-Protection': {
            'required': False,  # Deprecated but still useful
            'severity': VulnSeverity.LOW,
            'recommended': '1; mode=block',
            'description': 'Missing X-XSS-Protection header'
        },
        'Content-Security-Policy': {
            'required': True,
            'severity': VulnSeverity.MEDIUM,
            'recommended': "default-src 'self'",
            'description': 'Missing CSP - XSS attacks more impactful'
        },
        'Referrer-Policy': {
            'required': True,
            'severity': VulnSeverity.LOW,
            'recommended': 'strict-origin-when-cross-origin',
            'description': 'Missing Referrer-Policy - information leakage'
        },
        'Permissions-Policy': {
            'required': False,
            'severity': VulnSeverity.LOW,
            'recommended': 'geolocation=(), microphone=(), camera=()',
            'description': 'Missing Permissions-Policy'
        },
    }

    # Dangerous headers to check for information disclosure
    INFO_DISCLOSURE_HEADERS = [
        'Server', 'X-Powered-By', 'X-AspNet-Version', 'X-AspNetMvc-Version'
    ]

    def __init__(self):
        self._vulnerabilities: Dict[str, List[Vulnerability]] = {}
        self._ssl_findings: Dict[str, List[SSLFinding]] = {}
        self._header_findings: Dict[str, List[HeaderFinding]] = {}

    def scan_host(self, host_info: HostInfo) -> List[Vulnerability]:
        """
        Scan host for vulnerabilities based on service detection

        Args:
            host_info: HostInfo from reconnaissance

        Returns:
            List of discovered vulnerabilities
        """
        vulnerabilities = []

        # Scan each service
        for service in host_info.services:
            service_vulns = self.check_service_vulnerabilities(service)
            vulnerabilities.extend(service_vulns)

        # SSL/TLS scan for HTTPS services
        https_ports = [s.port for s in host_info.services
                      if s.name in ['https', 'ssl', 'tls'] or s.port in [443, 8443]]
        for port in https_ports:
            ssl_vulns = self.scan_ssl(host_info.ip, port)
            vulnerabilities.extend(ssl_vulns)

        # HTTP header scan for web services
        http_ports = [s.port for s in host_info.services
                     if s.name in ['http', 'https'] or s.port in [80, 443, 8080, 8443]]
        for port in http_ports:
            header_vulns = self.scan_http_headers(host_info.ip, port)
            vulnerabilities.extend(header_vulns)

        # Check for misconfigurations
        misconfig_vulns = self.check_misconfigurations(host_info)
        vulnerabilities.extend(misconfig_vulns)

        # Store results
        self._vulnerabilities[host_info.ip] = vulnerabilities

        return vulnerabilities

    def check_service_vulnerabilities(self, service: ServiceInfo) -> List[Vulnerability]:
        """
        Check service for known vulnerabilities

        Args:
            service: ServiceInfo from port scan

        Returns:
            List of vulnerabilities
        """
        vulnerabilities = []

        # Normalize product name
        product = service.product.lower() if service.product else service.name.lower()
        version = service.version

        if not version:
            # Can't check without version
            return vulnerabilities

        # Search in vulnerability database
        for db_product, versions in self.VULN_DATABASE.items():
            if db_product in product:
                for vuln_version, vuln_list in versions.items():
                    if self._version_match(version, vuln_version):
                        for cve_id, cvss, description in vuln_list:
                            vuln = Vulnerability(
                                id=cve_id,
                                title=f"{db_product} {vuln_version} - {description}",
                                description=description,
                                severity=VulnSeverity.from_cvss(cvss),
                                cvss_score=cvss,
                                affected_component=f"{product} {version}",
                                affected_versions=[vuln_version],
                                evidence={
                                    'port': service.port,
                                    'protocol': service.protocol,
                                    'product': service.product,
                                    'version': service.version
                                }
                            )
                            vulnerabilities.append(vuln)

        # Query external CVE database
        external_vulns = self._query_cve_database(product, version)
        vulnerabilities.extend(external_vulns)

        return vulnerabilities

    def _version_match(self, detected: str, vulnerable: str) -> bool:
        """Check if detected version matches vulnerable version"""
        # Normalize versions
        detected = detected.split()[0] if detected else ""
        vulnerable = vulnerable.split()[0] if vulnerable else ""

        # Exact match
        if detected == vulnerable:
            return True

        # Major.minor match
        detected_parts = detected.split('.')
        vulnerable_parts = vulnerable.split('.')

        if len(detected_parts) >= 2 and len(vulnerable_parts) >= 2:
            if (detected_parts[0] == vulnerable_parts[0] and
                detected_parts[1] == vulnerable_parts[1]):
                # Check if detected version is <= vulnerable
                try:
                    d_patch = int(detected_parts[2]) if len(detected_parts) > 2 else 0
                    v_patch = int(vulnerable_parts[2]) if len(vulnerable_parts) > 2 else 0
                    return d_patch <= v_patch
                except ValueError:
                    return detected_parts[:2] == vulnerable_parts[:2]

        return False

    def _query_cve_database(self, product: str, version: str) -> List[Vulnerability]:
        """
        Query external CVE database (NVD)

        Args:
            product: Software product name
            version: Software version

        Returns:
            List of vulnerabilities from NVD
        """
        vulnerabilities = []

        try:
            # Query NVD API (rate-limited, use API key in production)
            url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
            params = {
                'keywordSearch': f"{product} {version}",
                'resultsPerPage': 20
            }

            response = requests.get(url, params=params, timeout=30)
            if response.status_code == 200:
                data = response.json()

                for item in data.get('vulnerabilities', []):
                    cve = item.get('cve', {})
                    cve_id = cve.get('id', '')

                    # Get description
                    descriptions = cve.get('descriptions', [])
                    description = ''
                    for desc in descriptions:
                        if desc.get('lang') == 'en':
                            description = desc.get('value', '')
                            break

                    # Get CVSS score
                    metrics = cve.get('metrics', {})
                    cvss_score = 0.0
                    cvss_vector = ''

                    if 'cvssMetricV31' in metrics:
                        cvss_data = metrics['cvssMetricV31'][0]['cvssData']
                        cvss_score = cvss_data.get('baseScore', 0.0)
                        cvss_vector = cvss_data.get('vectorString', '')
                    elif 'cvssMetricV2' in metrics:
                        cvss_data = metrics['cvssMetricV2'][0]['cvssData']
                        cvss_score = cvss_data.get('baseScore', 0.0)
                        cvss_vector = cvss_data.get('vectorString', '')

                    # Get references
                    references = [ref.get('url', '') for ref in cve.get('references', [])]

                    # Get CWE
                    cwe_id = ''
                    weaknesses = cve.get('weaknesses', [])
                    if weaknesses:
                        for weakness in weaknesses:
                            for desc in weakness.get('description', []):
                                if desc.get('lang') == 'en':
                                    cwe_id = desc.get('value', '')
                                    break

                    vuln = Vulnerability(
                        id=cve_id,
                        title=f"{cve_id} - {product}",
                        description=description[:500] if description else '',
                        severity=VulnSeverity.from_cvss(cvss_score),
                        cvss_score=cvss_score,
                        cvss_vector=cvss_vector,
                        affected_component=product,
                        affected_versions=[version],
                        references=references[:5],
                        cwe_id=cwe_id
                    )
                    vulnerabilities.append(vuln)

        except requests.exceptions.Timeout:
            logger.warning("[VULN] NVD API timeout")
        except Exception as e:
            logger.error(f"[VULN] CVE query error: {e}")

        return vulnerabilities

    def scan_ssl(self, host: str, port: int = 443) -> List[Vulnerability]:
        """
        Analyze SSL/TLS configuration

        Args:
            host: Target hostname or IP
            port: SSL port to scan

        Returns:
            List of SSL-related vulnerabilities
        """
        vulnerabilities = []
        findings = []

        # Test supported protocols
        protocols = [
            ('SSLv2', ssl.PROTOCOL_SSLv23),
            ('SSLv3', ssl.PROTOCOL_SSLv23),
            ('TLSv1.0', ssl.PROTOCOL_TLSv1 if hasattr(ssl, 'PROTOCOL_TLSv1') else None),
            ('TLSv1.1', ssl.PROTOCOL_TLSv1_1 if hasattr(ssl, 'PROTOCOL_TLSv1_1') else None),
            ('TLSv1.2', ssl.PROTOCOL_TLSv1_2 if hasattr(ssl, 'PROTOCOL_TLSv1_2') else None),
        ]

        for proto_name, proto_const in protocols:
            if proto_const is None:
                continue

            try:
                context = ssl.SSLContext(proto_const)
                context.check_hostname = False
                context.verify_mode = ssl.CERT_NONE

                # Try to set specific protocol options
                if proto_name == 'SSLv2':
                    try:
                        context.options &= ~ssl.OP_NO_SSLv2
                    except:
                        continue
                elif proto_name == 'SSLv3':
                    try:
                        context.options &= ~ssl.OP_NO_SSLv3
                    except:
                        continue

                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(5)

                ssl_sock = context.wrap_socket(sock, server_hostname=host)
                ssl_sock.connect((host, port))

                # Protocol supported
                if proto_name.lower() in self.WEAK_SSL_CONFIGS:
                    issue, severity, recommendation = self.WEAK_SSL_CONFIGS[proto_name.lower()]
                    finding = SSLFinding(
                        issue=issue,
                        severity=severity,
                        details=f"Server accepts {proto_name} connections",
                        recommendation=recommendation
                    )
                    findings.append(finding)

                    vuln = Vulnerability(
                        id=f"SSL-WEAK-{proto_name.upper()}",
                        title=issue,
                        description=f"Server supports deprecated {proto_name} protocol",
                        severity=severity,
                        remediation=recommendation,
                        evidence={'protocol': proto_name, 'port': port}
                    )
                    vulnerabilities.append(vuln)

                ssl_sock.close()

            except ssl.SSLError:
                # Protocol not supported (good)
                pass
            except socket.error:
                pass
            except Exception as e:
                logger.debug(f"[VULN] SSL test error for {proto_name}: {e}")

        # Get certificate information
        try:
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE

            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(10)

            ssl_sock = context.wrap_socket(sock, server_hostname=host)
            ssl_sock.connect((host, port))

            cert = ssl_sock.getpeercert(binary_form=False)
            cipher = ssl_sock.cipher()

            ssl_sock.close()

            # Check cipher suite
            if cipher:
                cipher_name = cipher[0]
                for weak in self.WEAK_CIPHERS:
                    if weak in cipher_name:
                        vuln = Vulnerability(
                            id=f"SSL-WEAK-CIPHER-{weak}",
                            title=f"Weak cipher suite: {weak}",
                            description=f"Server using weak cipher: {cipher_name}",
                            severity=VulnSeverity.MEDIUM,
                            remediation="Configure server to use strong ciphers only",
                            evidence={'cipher': cipher_name, 'port': port}
                        )
                        vulnerabilities.append(vuln)

            # Check certificate expiration
            if cert:
                not_after = cert.get('notAfter')
                if not_after:
                    from datetime import datetime
                    try:
                        expiry = datetime.strptime(not_after, '%b %d %H:%M:%S %Y %Z')
                        if expiry < datetime.now():
                            vuln = Vulnerability(
                                id="SSL-CERT-EXPIRED",
                                title="SSL certificate expired",
                                description=f"Certificate expired on {not_after}",
                                severity=VulnSeverity.HIGH,
                                remediation="Renew SSL certificate",
                                evidence={'expiry': not_after, 'port': port}
                            )
                            vulnerabilities.append(vuln)
                    except ValueError:
                        pass

        except Exception as e:
            logger.debug(f"[VULN] SSL cert check error: {e}")

        # Store findings
        self._ssl_findings[f"{host}:{port}"] = findings

        return vulnerabilities

    def scan_http_headers(self, host: str, port: int = 80) -> List[Vulnerability]:
        """
        Scan HTTP security headers

        Args:
            host: Target hostname or IP
            port: HTTP port

        Returns:
            List of header-related vulnerabilities
        """
        vulnerabilities = []
        findings = []

        protocol = 'https' if port in [443, 8443] else 'http'
        url = f"{protocol}://{host}:{port}"

        try:
            response = requests.get(
                url,
                timeout=10,
                verify=False,
                allow_redirects=False,
                headers={'User-Agent': 'TSUNAMI/5.0 Security Scanner'}
            )

            headers = response.headers

            # Check required security headers
            for header_name, config in self.SECURITY_HEADERS.items():
                if header_name not in headers:
                    if config['required']:
                        finding = HeaderFinding(
                            header=header_name,
                            issue=config['description'],
                            severity=config['severity'],
                            current_value='Missing',
                            recommended_value=config['recommended']
                        )
                        findings.append(finding)

                        vuln = Vulnerability(
                            id=f"HTTP-HEADER-MISSING-{header_name.upper().replace('-', '_')}",
                            title=f"Missing {header_name} header",
                            description=config['description'],
                            severity=config['severity'],
                            remediation=f"Add header: {header_name}: {config['recommended']}",
                            evidence={'url': url, 'header': header_name}
                        )
                        vulnerabilities.append(vuln)

            # Check for information disclosure
            for header in self.INFO_DISCLOSURE_HEADERS:
                if header in headers:
                    value = headers[header]
                    finding = HeaderFinding(
                        header=header,
                        issue=f"Information disclosure via {header} header",
                        severity=VulnSeverity.INFO,
                        current_value=value,
                        recommended_value='Remove or obfuscate'
                    )
                    findings.append(finding)

                    vuln = Vulnerability(
                        id=f"HTTP-INFO-DISCLOSURE-{header.upper().replace('-', '_')}",
                        title=f"Information disclosure: {header}",
                        description=f"Server reveals technology information: {value}",
                        severity=VulnSeverity.INFO,
                        remediation=f"Remove or obfuscate {header} header",
                        evidence={'url': url, 'header': header, 'value': value}
                    )
                    vulnerabilities.append(vuln)

            # Check CORS configuration
            cors_header = headers.get('Access-Control-Allow-Origin')
            if cors_header == '*':
                vuln = Vulnerability(
                    id="HTTP-CORS-WILDCARD",
                    title="CORS wildcard configuration",
                    description="Access-Control-Allow-Origin set to * allows any origin",
                    severity=VulnSeverity.MEDIUM,
                    remediation="Restrict CORS to specific trusted origins",
                    evidence={'url': url, 'cors': cors_header}
                )
                vulnerabilities.append(vuln)

            # Check cookie security
            for cookie in response.cookies:
                issues = []
                if not cookie.secure and protocol == 'https':
                    issues.append('Secure flag missing')
                if 'httponly' not in str(cookie).lower():
                    issues.append('HttpOnly flag missing')
                if 'samesite' not in str(cookie).lower():
                    issues.append('SameSite flag missing')

                if issues:
                    vuln = Vulnerability(
                        id=f"HTTP-COOKIE-INSECURE-{cookie.name.upper()[:20]}",
                        title=f"Insecure cookie: {cookie.name}",
                        description=f"Cookie security issues: {', '.join(issues)}",
                        severity=VulnSeverity.LOW,
                        remediation="Add Secure, HttpOnly, and SameSite flags",
                        evidence={'url': url, 'cookie': cookie.name, 'issues': issues}
                    )
                    vulnerabilities.append(vuln)

        except requests.exceptions.SSLError as e:
            vuln = Vulnerability(
                id="HTTP-SSL-ERROR",
                title="SSL/TLS Error",
                description=f"SSL error connecting to server: {str(e)[:100]}",
                severity=VulnSeverity.HIGH,
                evidence={'url': url, 'error': str(e)[:200]}
            )
            vulnerabilities.append(vuln)
        except requests.exceptions.ConnectionError:
            logger.debug(f"[VULN] Connection failed to {url}")
        except Exception as e:
            logger.error(f"[VULN] Header scan error: {e}")

        # Store findings
        self._header_findings[f"{host}:{port}"] = findings

        return vulnerabilities

    def check_misconfigurations(self, host_info: HostInfo) -> List[Vulnerability]:
        """
        Check for common misconfigurations

        Args:
            host_info: HostInfo from reconnaissance

        Returns:
            List of misconfiguration vulnerabilities
        """
        vulnerabilities = []

        # Check for dangerous open services
        dangerous_services = {
            23: ('Telnet', VulnSeverity.HIGH, 'Unencrypted remote access'),
            21: ('FTP', VulnSeverity.MEDIUM, 'FTP transmits credentials in plaintext'),
            512: ('rexec', VulnSeverity.HIGH, 'Remote execution service'),
            513: ('rlogin', VulnSeverity.HIGH, 'Remote login service'),
            514: ('rsh', VulnSeverity.HIGH, 'Remote shell service'),
            111: ('rpcbind', VulnSeverity.MEDIUM, 'RPC portmapper exposed'),
            135: ('MSRPC', VulnSeverity.MEDIUM, 'Microsoft RPC exposed'),
            445: ('SMB', VulnSeverity.MEDIUM, 'SMB directly exposed'),
            3389: ('RDP', VulnSeverity.MEDIUM, 'RDP exposed to internet'),
            1433: ('MSSQL', VulnSeverity.HIGH, 'SQL Server exposed'),
            3306: ('MySQL', VulnSeverity.HIGH, 'MySQL exposed'),
            5432: ('PostgreSQL', VulnSeverity.HIGH, 'PostgreSQL exposed'),
            6379: ('Redis', VulnSeverity.CRITICAL, 'Redis exposed (often no auth)'),
            27017: ('MongoDB', VulnSeverity.CRITICAL, 'MongoDB exposed'),
            9200: ('Elasticsearch', VulnSeverity.HIGH, 'Elasticsearch exposed'),
            5601: ('Kibana', VulnSeverity.HIGH, 'Kibana exposed'),
            2375: ('Docker', VulnSeverity.CRITICAL, 'Docker API exposed'),
            2376: ('Docker TLS', VulnSeverity.HIGH, 'Docker API exposed'),
            10250: ('Kubelet', VulnSeverity.CRITICAL, 'Kubernetes kubelet exposed'),
        }

        for port in host_info.ports:
            if port.state == 'open' and port.port in dangerous_services:
                service_name, severity, description = dangerous_services[port.port]
                vuln = Vulnerability(
                    id=f"MISCONFIG-{service_name.upper()}-EXPOSED",
                    title=f"{service_name} service exposed",
                    description=description,
                    severity=severity,
                    remediation=f"Restrict access to {service_name} or disable if not needed",
                    evidence={'port': port.port, 'service': service_name}
                )
                vulnerabilities.append(vuln)

        # Check for default credentials indicators
        for service in host_info.services:
            if service.extra_info and 'default' in service.extra_info.lower():
                vuln = Vulnerability(
                    id=f"MISCONFIG-DEFAULT-CONFIG-{service.port}",
                    title=f"Possible default configuration on port {service.port}",
                    description=f"Service may be using default configuration: {service.extra_info}",
                    severity=VulnSeverity.MEDIUM,
                    evidence={'port': service.port, 'info': service.extra_info}
                )
                vulnerabilities.append(vuln)

        return vulnerabilities

    def get_results(self, host: str = None) -> Dict[str, List[Vulnerability]]:
        """Get stored vulnerability results"""
        if host:
            return {host: self._vulnerabilities.get(host, [])}
        return dict(self._vulnerabilities)

    def get_ssl_findings(self, host_port: str = None) -> Dict[str, List[SSLFinding]]:
        """Get SSL findings"""
        if host_port:
            return {host_port: self._ssl_findings.get(host_port, [])}
        return dict(self._ssl_findings)

    def get_header_findings(self, host_port: str = None) -> Dict[str, List[HeaderFinding]]:
        """Get header findings"""
        if host_port:
            return {host_port: self._header_findings.get(host_port, [])}
        return dict(self._header_findings)

    def export_results(self, format: str = 'json') -> str:
        """Export all results"""
        if format == 'json':
            return json.dumps({
                'vulnerabilities': {
                    k: [asdict(v) for v in vs]
                    for k, vs in self._vulnerabilities.items()
                },
                'ssl_findings': {
                    k: [asdict(f) for f in fs]
                    for k, fs in self._ssl_findings.items()
                },
                'header_findings': {
                    k: [asdict(f) for f in fs]
                    for k, fs in self._header_findings.items()
                }
            }, indent=2, default=str)
        raise ValueError(f"Unsupported format: {format}")


# Singleton instance
_vuln_scanner: Optional[VulnScanner] = None

def get_vuln_scanner() -> VulnScanner:
    """Get singleton VulnScanner instance"""
    global _vuln_scanner
    if _vuln_scanner is None:
        _vuln_scanner = VulnScanner()
    return _vuln_scanner
