#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
================================================================================
    TSUNAMI VULNERABILITY SCORER v5.0
    CVE Analysis & Exploitation Probability Prediction
================================================================================

    Features:
    - Real NVD API Integration for CVE Data
    - CVSS Score Enhancement
    - Exploitability Prediction
    - Threat Intelligence Correlation
    - Prioritization Scoring

================================================================================
"""

import os
import json
import logging
import requests
import hashlib
import numpy as np
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any, Set
from dataclasses import dataclass, field, asdict
from enum import Enum
from collections import defaultdict
from concurrent.futures import ThreadPoolExecutor, as_completed
import threading
import time

# ML Libraries
from sklearn.ensemble import RandomForestClassifier, GradientBoostingRegressor
from sklearn.preprocessing import StandardScaler, LabelEncoder
import joblib

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class ExploitMaturity(Enum):
    """Exploit availability and maturity levels"""
    NOT_DEFINED = "not_defined"
    UNPROVEN = "unproven"           # Theoretical or unproven
    POC = "poc"                      # Proof-of-concept exists
    FUNCTIONAL = "functional"        # Working exploit available
    HIGH = "high"                    # Weaponized, actively exploited


class RiskLevel(Enum):
    """Overall risk levels"""
    CRITICAL = 5
    HIGH = 4
    MEDIUM = 3
    LOW = 2
    INFORMATIONAL = 1


class AssetCriticality(Enum):
    """Asset criticality levels"""
    MISSION_CRITICAL = 5
    HIGH = 4
    MEDIUM = 3
    LOW = 2
    MINIMAL = 1


@dataclass
class CVEData:
    """CVE (Common Vulnerabilities and Exposures) data"""
    cve_id: str
    description: str
    published_date: datetime
    last_modified: datetime
    cvss_v3_score: Optional[float] = None
    cvss_v3_vector: Optional[str] = None
    cvss_v2_score: Optional[float] = None
    cvss_v2_vector: Optional[str] = None
    attack_vector: Optional[str] = None
    attack_complexity: Optional[str] = None
    privileges_required: Optional[str] = None
    user_interaction: Optional[str] = None
    scope: Optional[str] = None
    confidentiality_impact: Optional[str] = None
    integrity_impact: Optional[str] = None
    availability_impact: Optional[str] = None
    cwe_ids: List[str] = field(default_factory=list)
    references: List[str] = field(default_factory=list)
    vendor: Optional[str] = None
    product: Optional[str] = None
    affected_versions: List[str] = field(default_factory=list)
    exploit_available: bool = False
    exploit_maturity: ExploitMaturity = ExploitMaturity.NOT_DEFINED
    epss_score: Optional[float] = None  # Exploit Prediction Scoring System
    kev_listed: bool = False  # CISA Known Exploited Vulnerabilities


@dataclass
class ExploitabilityScore:
    """Comprehensive exploitability scoring"""
    cve_id: str
    timestamp: datetime
    base_score: float  # CVSS base score
    temporal_score: float  # Time-adjusted score
    environmental_score: float  # Environment-adjusted score
    exploitability_probability: float  # 0.0 - 1.0
    exploit_maturity: ExploitMaturity
    threat_intel_score: float  # Based on threat intel
    final_priority_score: float  # Combined score 0-100
    risk_level: RiskLevel
    factors: Dict[str, float] = field(default_factory=dict)
    recommendations: List[str] = field(default_factory=list)
    time_to_exploit_days: Optional[float] = None


@dataclass
class VulnerabilityAssessment:
    """Complete vulnerability assessment for an asset"""
    asset_id: str
    asset_type: str
    scan_time: datetime
    vulnerabilities: List[ExploitabilityScore]
    overall_risk_score: float
    critical_count: int
    high_count: int
    medium_count: int
    low_count: int
    top_priorities: List[str]  # Top CVEs to fix
    attack_surface_score: float


class NVDClient:
    """
    NIST National Vulnerability Database API Client

    Rate limited to 5 requests per 30 seconds (without API key)
    or 50 requests per 30 seconds (with API key)
    """

    NVD_API_BASE = "https://services.nvd.nist.gov/rest/json/cves/2.0"
    KEV_URL = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json"

    def __init__(self, api_key: Optional[str] = None):
        """
        Initialize NVD Client

        Args:
            api_key: Optional NVD API key for higher rate limits
        """
        self.api_key = api_key or os.environ.get('NVD_API_KEY')
        self.session = requests.Session()

        if self.api_key:
            self.session.headers['apiKey'] = self.api_key
            self.rate_limit = 50  # requests per 30 seconds
        else:
            self.rate_limit = 5

        self.request_times: List[datetime] = []
        self._lock = threading.Lock()

        # Cache
        self.cve_cache: Dict[str, CVEData] = {}
        self.kev_list: Set[str] = set()
        self.last_kev_update: Optional[datetime] = None

    def _rate_limit_wait(self):
        """Enforce rate limiting"""
        with self._lock:
            now = datetime.now()
            # Remove requests older than 30 seconds
            self.request_times = [
                t for t in self.request_times
                if (now - t).total_seconds() < 30
            ]

            if len(self.request_times) >= self.rate_limit:
                # Wait until oldest request expires
                oldest = min(self.request_times)
                wait_time = 30 - (now - oldest).total_seconds()
                if wait_time > 0:
                    logger.debug(f"Rate limiting: waiting {wait_time:.1f}s")
                    time.sleep(wait_time + 0.1)

            self.request_times.append(datetime.now())

    def _load_kev_list(self):
        """Load CISA Known Exploited Vulnerabilities list"""
        try:
            if (self.last_kev_update and
                (datetime.now() - self.last_kev_update).total_seconds() < 86400):
                return  # Already loaded within last 24 hours

            response = self.session.get(self.KEV_URL, timeout=30)
            if response.status_code == 200:
                data = response.json()
                self.kev_list = {
                    v['cveID']
                    for v in data.get('vulnerabilities', [])
                }
                self.last_kev_update = datetime.now()
                logger.info(f"Loaded {len(self.kev_list)} KEV entries")
            else:
                logger.warning(f"Failed to load KEV list: {response.status_code}")

        except Exception as e:
            logger.warning(f"Error loading KEV list: {e}")

    def fetch_cve(self, cve_id: str) -> Optional[CVEData]:
        """
        Fetch CVE data from NVD API

        Args:
            cve_id: CVE identifier (e.g., CVE-2021-44228)

        Returns:
            CVEData object or None if not found
        """
        # Check cache first
        if cve_id in self.cve_cache:
            return self.cve_cache[cve_id]

        # Load KEV list if needed
        self._load_kev_list()

        # Rate limit
        self._rate_limit_wait()

        try:
            url = f"{self.NVD_API_BASE}?cveId={cve_id}"
            response = self.session.get(url, timeout=30)

            if response.status_code != 200:
                logger.warning(f"NVD API error for {cve_id}: {response.status_code}")
                return None

            data = response.json()
            vulnerabilities = data.get('vulnerabilities', [])

            if not vulnerabilities:
                return None

            vuln = vulnerabilities[0]['cve']

            # Parse CVE data
            cve_data = self._parse_cve_response(vuln, cve_id)

            # Check if in KEV list
            cve_data.kev_listed = cve_id in self.kev_list

            # Cache result
            self.cve_cache[cve_id] = cve_data

            return cve_data

        except requests.RequestException as e:
            logger.error(f"Request error fetching {cve_id}: {e}")
            return None
        except Exception as e:
            logger.error(f"Error parsing {cve_id}: {e}")
            return None

    def _parse_cve_response(self, vuln: Dict, cve_id: str) -> CVEData:
        """Parse NVD API response into CVEData"""
        # Get description
        descriptions = vuln.get('descriptions', [])
        description = next(
            (d['value'] for d in descriptions if d.get('lang') == 'en'),
            descriptions[0]['value'] if descriptions else ''
        )

        # Parse dates
        published = datetime.fromisoformat(
            vuln.get('published', '2000-01-01T00:00:00').replace('Z', '+00:00')
        )
        modified = datetime.fromisoformat(
            vuln.get('lastModified', vuln.get('published', '2000-01-01T00:00:00')).replace('Z', '+00:00')
        )

        # Parse CVSS v3
        cvss_v3_score = None
        cvss_v3_vector = None
        attack_vector = None
        attack_complexity = None
        privileges_required = None
        user_interaction = None
        scope = None
        confidentiality_impact = None
        integrity_impact = None
        availability_impact = None

        metrics = vuln.get('metrics', {})

        # Try CVSS 3.1 first, then 3.0
        cvss_v3 = metrics.get('cvssMetricV31', metrics.get('cvssMetricV30', []))
        if cvss_v3:
            cvss_data = cvss_v3[0].get('cvssData', {})
            cvss_v3_score = cvss_data.get('baseScore')
            cvss_v3_vector = cvss_data.get('vectorString')
            attack_vector = cvss_data.get('attackVector')
            attack_complexity = cvss_data.get('attackComplexity')
            privileges_required = cvss_data.get('privilegesRequired')
            user_interaction = cvss_data.get('userInteraction')
            scope = cvss_data.get('scope')
            confidentiality_impact = cvss_data.get('confidentialityImpact')
            integrity_impact = cvss_data.get('integrityImpact')
            availability_impact = cvss_data.get('availabilityImpact')

        # Parse CVSS v2
        cvss_v2_score = None
        cvss_v2_vector = None
        cvss_v2 = metrics.get('cvssMetricV2', [])
        if cvss_v2:
            cvss_v2_score = cvss_v2[0].get('cvssData', {}).get('baseScore')
            cvss_v2_vector = cvss_v2[0].get('cvssData', {}).get('vectorString')

        # Parse CWE IDs
        weaknesses = vuln.get('weaknesses', [])
        cwe_ids = []
        for weakness in weaknesses:
            for desc in weakness.get('description', []):
                if desc.get('lang') == 'en':
                    cwe_ids.append(desc.get('value', ''))

        # Parse references
        references = [
            ref.get('url', '')
            for ref in vuln.get('references', [])
        ]

        # Check for exploit references
        exploit_available = any(
            'exploit' in ref.lower() or 'github.com' in ref.lower()
            for ref in references
        )

        return CVEData(
            cve_id=cve_id,
            description=description,
            published_date=published,
            last_modified=modified,
            cvss_v3_score=cvss_v3_score,
            cvss_v3_vector=cvss_v3_vector,
            cvss_v2_score=cvss_v2_score,
            cvss_v2_vector=cvss_v2_vector,
            attack_vector=attack_vector,
            attack_complexity=attack_complexity,
            privileges_required=privileges_required,
            user_interaction=user_interaction,
            scope=scope,
            confidentiality_impact=confidentiality_impact,
            integrity_impact=integrity_impact,
            availability_impact=availability_impact,
            cwe_ids=cwe_ids,
            references=references[:10],  # Limit references
            exploit_available=exploit_available
        )

    def search_cves(
        self,
        keyword: Optional[str] = None,
        product: Optional[str] = None,
        vendor: Optional[str] = None,
        cvss_severity: Optional[str] = None,
        last_modified_days: int = 30,
        limit: int = 50
    ) -> List[CVEData]:
        """
        Search for CVEs matching criteria

        Args:
            keyword: Search keyword
            product: Product name
            vendor: Vendor name
            cvss_severity: Severity level (LOW, MEDIUM, HIGH, CRITICAL)
            last_modified_days: Only CVEs modified in last N days
            limit: Maximum results

        Returns:
            List of CVEData objects
        """
        self._rate_limit_wait()

        params = {
            'resultsPerPage': min(limit, 100)
        }

        if keyword:
            params['keywordSearch'] = keyword

        if cvss_severity:
            params['cvssV3Severity'] = cvss_severity

        if last_modified_days:
            start_date = (datetime.now() - timedelta(days=last_modified_days)).strftime('%Y-%m-%dT00:00:00.000')
            params['lastModStartDate'] = start_date

        try:
            response = self.session.get(self.NVD_API_BASE, params=params, timeout=60)

            if response.status_code != 200:
                logger.warning(f"NVD search error: {response.status_code}")
                return []

            data = response.json()
            vulnerabilities = data.get('vulnerabilities', [])

            cves = []
            for vuln in vulnerabilities[:limit]:
                cve_id = vuln.get('cve', {}).get('id')
                if cve_id:
                    cve_data = self._parse_cve_response(vuln['cve'], cve_id)
                    cve_data.kev_listed = cve_id in self.kev_list
                    cves.append(cve_data)
                    self.cve_cache[cve_id] = cve_data

            return cves

        except Exception as e:
            logger.error(f"NVD search error: {e}")
            return []


class VulnerabilityScorer:
    """
    Vulnerability Risk Scoring Engine

    Combines multiple factors:
    - CVSS base score
    - Exploit availability/maturity
    - Threat intelligence
    - Asset criticality
    - Time-based factors
    """

    # EPSS-like scoring weights
    EXPLOIT_MATURITY_WEIGHTS = {
        ExploitMaturity.NOT_DEFINED: 1.0,
        ExploitMaturity.UNPROVEN: 1.2,
        ExploitMaturity.POC: 1.5,
        ExploitMaturity.FUNCTIONAL: 2.0,
        ExploitMaturity.HIGH: 3.0,
    }

    # Attack vector weights
    ATTACK_VECTOR_WEIGHTS = {
        'NETWORK': 1.0,
        'ADJACENT_NETWORK': 0.8,
        'LOCAL': 0.6,
        'PHYSICAL': 0.3,
    }

    # Privileges required weights
    PRIVILEGES_WEIGHTS = {
        'NONE': 1.0,
        'LOW': 0.8,
        'HIGH': 0.5,
    }

    def __init__(
        self,
        nvd_api_key: Optional[str] = None,
        model_path: Optional[str] = None
    ):
        """
        Initialize Vulnerability Scorer

        Args:
            nvd_api_key: Optional NVD API key
            model_path: Path to save/load models
        """
        self.nvd_client = NVDClient(api_key=nvd_api_key)
        self.model_path = model_path or "/tmp/tsunami_vuln_models"

        # Exploitability predictor
        self.exploit_predictor = GradientBoostingRegressor(
            n_estimators=100,
            max_depth=5,
            learning_rate=0.1,
            random_state=42
        )

        # Feature scaler
        self.scaler = StandardScaler()

        # Threat intel cache (IOC -> score)
        self.threat_intel_scores: Dict[str, float] = {}

        # Known exploited CVEs (from threat intel)
        self.known_exploited: Set[str] = set()

        # Asset database
        self.assets: Dict[str, Dict] = {}

        # State
        self.is_trained = False

        # Thread safety
        self._lock = threading.Lock()

    def _extract_cve_features(self, cve: CVEData) -> np.ndarray:
        """Extract ML features from CVE data"""
        features = []

        # Base CVSS score
        features.append(cve.cvss_v3_score or cve.cvss_v2_score or 5.0)

        # Attack vector
        av_weight = self.ATTACK_VECTOR_WEIGHTS.get(cve.attack_vector, 0.5)
        features.append(av_weight)

        # Attack complexity (low = 1, high = 0.5)
        ac = 1.0 if cve.attack_complexity == 'LOW' else 0.5
        features.append(ac)

        # Privileges required
        pr_weight = self.PRIVILEGES_WEIGHTS.get(cve.privileges_required, 0.5)
        features.append(pr_weight)

        # User interaction (none = 1, required = 0.5)
        ui = 1.0 if cve.user_interaction == 'NONE' else 0.5
        features.append(ui)

        # Impact scores (mapped to numeric)
        impact_map = {'NONE': 0, 'LOW': 0.3, 'HIGH': 0.7}
        features.append(impact_map.get(cve.confidentiality_impact, 0.5))
        features.append(impact_map.get(cve.integrity_impact, 0.5))
        features.append(impact_map.get(cve.availability_impact, 0.5))

        # Age in days
        age_days = (datetime.now() - cve.published_date.replace(tzinfo=None)).days
        features.append(min(age_days, 3650))  # Cap at 10 years

        # Exploit available
        features.append(1.0 if cve.exploit_available else 0.0)

        # KEV listed
        features.append(1.0 if cve.kev_listed else 0.0)

        # Number of references (proxy for attention)
        features.append(min(len(cve.references), 20))

        return np.array(features)

    def calculate_exploitability(
        self,
        cve: CVEData,
        asset_criticality: AssetCriticality = AssetCriticality.MEDIUM
    ) -> ExploitabilityScore:
        """
        Calculate comprehensive exploitability score

        Args:
            cve: CVE data
            asset_criticality: Criticality of affected asset

        Returns:
            ExploitabilityScore with detailed scoring
        """
        # Base score from CVSS
        base_score = cve.cvss_v3_score or cve.cvss_v2_score or 5.0

        # Determine exploit maturity
        exploit_maturity = cve.exploit_maturity
        if cve.kev_listed:
            exploit_maturity = ExploitMaturity.HIGH
        elif cve.exploit_available:
            exploit_maturity = ExploitMaturity.FUNCTIONAL

        # Temporal score adjustments
        temporal_score = base_score

        # Exploit maturity factor
        maturity_factor = self.EXPLOIT_MATURITY_WEIGHTS.get(exploit_maturity, 1.0)
        temporal_score *= min(maturity_factor, 1.3)  # Cap at 30% increase

        # Age factor (newer = higher risk)
        age_days = (datetime.now() - cve.published_date.replace(tzinfo=None)).days
        if age_days < 30:
            temporal_score *= 1.2  # Very recent
        elif age_days < 90:
            temporal_score *= 1.1  # Recent
        elif age_days > 365:
            temporal_score *= 0.9  # Older

        # Environmental score (asset-based)
        environmental_score = temporal_score
        asset_factor = asset_criticality.value / 5.0  # Normalize to 0-1
        environmental_score *= (0.7 + asset_factor * 0.6)  # Range: 0.7 to 1.3

        # Threat intelligence score
        threat_intel_score = 0.0
        if cve.cve_id in self.threat_intel_scores:
            threat_intel_score = self.threat_intel_scores[cve.cve_id]
        elif cve.kev_listed:
            threat_intel_score = 0.9
        elif cve.exploit_available:
            threat_intel_score = 0.6

        # Calculate exploitability probability
        exploitability_prob = self._calculate_exploit_probability(cve)

        # Final priority score (0-100)
        final_score = (
            environmental_score * 6 +  # Max 60 points from CVSS
            threat_intel_score * 20 +   # Max 20 points from threat intel
            exploitability_prob * 20    # Max 20 points from exploit probability
        )
        final_score = min(max(final_score, 0), 100)

        # Determine risk level
        if final_score >= 80:
            risk_level = RiskLevel.CRITICAL
        elif final_score >= 60:
            risk_level = RiskLevel.HIGH
        elif final_score >= 40:
            risk_level = RiskLevel.MEDIUM
        elif final_score >= 20:
            risk_level = RiskLevel.LOW
        else:
            risk_level = RiskLevel.INFORMATIONAL

        # Estimate time to exploitation
        time_to_exploit = self._estimate_time_to_exploit(cve, exploit_maturity)

        # Generate recommendations
        recommendations = self._generate_recommendations(
            cve, risk_level, exploit_maturity
        )

        # Factor breakdown
        factors = {
            'cvss_base': base_score,
            'exploit_maturity': maturity_factor,
            'age_factor': 1.2 if age_days < 30 else 1.1 if age_days < 90 else 1.0,
            'asset_criticality': asset_factor,
            'threat_intel': threat_intel_score,
            'exploit_probability': exploitability_prob
        }

        return ExploitabilityScore(
            cve_id=cve.cve_id,
            timestamp=datetime.now(),
            base_score=base_score,
            temporal_score=temporal_score,
            environmental_score=environmental_score,
            exploitability_probability=exploitability_prob,
            exploit_maturity=exploit_maturity,
            threat_intel_score=threat_intel_score,
            final_priority_score=final_score,
            risk_level=risk_level,
            factors=factors,
            recommendations=recommendations,
            time_to_exploit_days=time_to_exploit
        )

    def _calculate_exploit_probability(self, cve: CVEData) -> float:
        """Calculate probability of exploitation (EPSS-like)"""
        # Use ML model if trained
        if self.is_trained:
            features = self._extract_cve_features(cve)
            scaled = self.scaler.transform(features.reshape(1, -1))
            return float(self.exploit_predictor.predict(scaled)[0])

        # Heuristic calculation
        prob = 0.1  # Base probability

        # CVSS score contribution
        cvss = cve.cvss_v3_score or cve.cvss_v2_score or 5.0
        prob += (cvss / 10) * 0.3

        # Attack vector
        if cve.attack_vector == 'NETWORK':
            prob += 0.2
        elif cve.attack_vector == 'ADJACENT_NETWORK':
            prob += 0.1

        # Low complexity increases probability
        if cve.attack_complexity == 'LOW':
            prob += 0.15

        # No privileges required
        if cve.privileges_required == 'NONE':
            prob += 0.1

        # Exploit available
        if cve.exploit_available:
            prob += 0.2

        # KEV listed
        if cve.kev_listed:
            prob += 0.3

        # Recent CVE
        age_days = (datetime.now() - cve.published_date.replace(tzinfo=None)).days
        if age_days < 30:
            prob += 0.1

        return min(prob, 1.0)

    def _estimate_time_to_exploit(
        self,
        cve: CVEData,
        maturity: ExploitMaturity
    ) -> Optional[float]:
        """Estimate days until exploitation (if not already exploited)"""
        if maturity == ExploitMaturity.HIGH:
            return 0  # Already actively exploited

        if maturity == ExploitMaturity.FUNCTIONAL:
            return 7  # Within a week

        if maturity == ExploitMaturity.POC:
            return 30  # Within a month

        # Based on CVSS and other factors
        cvss = cve.cvss_v3_score or cve.cvss_v2_score or 5.0

        if cvss >= 9.0:
            return 14  # Critical = 2 weeks
        elif cvss >= 7.0:
            return 45  # High = 1.5 months
        elif cvss >= 4.0:
            return 90  # Medium = 3 months
        else:
            return 180  # Low = 6 months

    def _generate_recommendations(
        self,
        cve: CVEData,
        risk_level: RiskLevel,
        maturity: ExploitMaturity
    ) -> List[str]:
        """Generate remediation recommendations"""
        recommendations = []

        # Risk-level based
        if risk_level == RiskLevel.CRITICAL:
            recommendations.append("IMMEDIATE: Patch or apply workaround within 24-48 hours")
            recommendations.append("Consider network isolation of affected systems")
        elif risk_level == RiskLevel.HIGH:
            recommendations.append("HIGH PRIORITY: Patch within 7 days")
            recommendations.append("Increase monitoring on affected systems")
        elif risk_level == RiskLevel.MEDIUM:
            recommendations.append("Schedule patching within 30 days")
        else:
            recommendations.append("Add to regular patching schedule")

        # Maturity-based
        if maturity in (ExploitMaturity.HIGH, ExploitMaturity.FUNCTIONAL):
            recommendations.append("Review logs for potential exploitation attempts")
            recommendations.append("Deploy IDS/IPS signatures if available")

        # Attack vector specific
        if cve.attack_vector == 'NETWORK':
            recommendations.append("Review firewall rules to limit exposure")

        # KEV listed
        if cve.kev_listed:
            recommendations.append("CISA KEV: Federal agencies must remediate immediately")

        return recommendations[:5]

    def score_cve(
        self,
        cve_id: str,
        asset_criticality: AssetCriticality = AssetCriticality.MEDIUM
    ) -> Optional[ExploitabilityScore]:
        """
        Score a CVE by ID (fetches from NVD if needed)

        Args:
            cve_id: CVE identifier
            asset_criticality: Criticality of affected asset

        Returns:
            ExploitabilityScore or None
        """
        cve = self.nvd_client.fetch_cve(cve_id)
        if not cve:
            return None

        return self.calculate_exploitability(cve, asset_criticality)

    def score_multiple_cves(
        self,
        cve_ids: List[str],
        asset_criticality: AssetCriticality = AssetCriticality.MEDIUM,
        max_workers: int = 5
    ) -> List[ExploitabilityScore]:
        """
        Score multiple CVEs in parallel

        Args:
            cve_ids: List of CVE identifiers
            asset_criticality: Criticality of affected assets
            max_workers: Maximum parallel workers

        Returns:
            List of ExploitabilityScores
        """
        scores = []

        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            future_to_cve = {
                executor.submit(self.score_cve, cve_id, asset_criticality): cve_id
                for cve_id in cve_ids
            }

            for future in as_completed(future_to_cve):
                cve_id = future_to_cve[future]
                try:
                    score = future.result()
                    if score:
                        scores.append(score)
                except Exception as e:
                    logger.error(f"Error scoring {cve_id}: {e}")

        # Sort by priority score (highest first)
        scores.sort(key=lambda s: s.final_priority_score, reverse=True)

        return scores

    def assess_asset(
        self,
        asset_id: str,
        cve_ids: List[str],
        asset_type: str = "server",
        asset_criticality: AssetCriticality = AssetCriticality.MEDIUM
    ) -> VulnerabilityAssessment:
        """
        Comprehensive vulnerability assessment for an asset

        Args:
            asset_id: Asset identifier
            cve_ids: List of CVEs affecting the asset
            asset_type: Type of asset
            asset_criticality: Criticality level

        Returns:
            VulnerabilityAssessment
        """
        # Score all CVEs
        scores = self.score_multiple_cves(cve_ids, asset_criticality)

        # Count by risk level
        critical_count = sum(1 for s in scores if s.risk_level == RiskLevel.CRITICAL)
        high_count = sum(1 for s in scores if s.risk_level == RiskLevel.HIGH)
        medium_count = sum(1 for s in scores if s.risk_level == RiskLevel.MEDIUM)
        low_count = sum(1 for s in scores if s.risk_level == RiskLevel.LOW)

        # Calculate overall risk score
        if scores:
            overall_risk = np.mean([s.final_priority_score for s in scores])
            # Weight toward highest scores
            top_5_avg = np.mean([s.final_priority_score for s in scores[:5]])
            overall_risk = (overall_risk + top_5_avg * 2) / 3
        else:
            overall_risk = 0

        # Calculate attack surface score (based on exploitable vulns)
        exploitable_count = sum(
            1 for s in scores
            if s.exploit_maturity in (ExploitMaturity.FUNCTIONAL, ExploitMaturity.HIGH)
        )
        attack_surface = min(exploitable_count / max(len(scores), 1), 1.0)

        # Top priorities
        top_priorities = [s.cve_id for s in scores[:10]]

        return VulnerabilityAssessment(
            asset_id=asset_id,
            asset_type=asset_type,
            scan_time=datetime.now(),
            vulnerabilities=scores,
            overall_risk_score=overall_risk,
            critical_count=critical_count,
            high_count=high_count,
            medium_count=medium_count,
            low_count=low_count,
            top_priorities=top_priorities,
            attack_surface_score=attack_surface
        )

    def update_threat_intel(
        self,
        intel_data: List[Dict[str, Any]]
    ):
        """
        Update threat intelligence data

        Args:
            intel_data: List of threat intel entries with CVE associations
        """
        with self._lock:
            for entry in intel_data:
                cve_ids = entry.get('cve_ids', [])
                threat_score = entry.get('threat_score', 0.5)
                is_exploited = entry.get('actively_exploited', False)

                for cve_id in cve_ids:
                    self.threat_intel_scores[cve_id] = threat_score
                    if is_exploited:
                        self.known_exploited.add(cve_id)

            logger.info(f"Updated threat intel with {len(intel_data)} entries")

    def train_exploit_predictor(
        self,
        training_data: List[Tuple[CVEData, float]]
    ) -> Dict[str, Any]:
        """
        Train the exploit probability predictor

        Args:
            training_data: List of (CVEData, exploitation_label) tuples
                          where label is 0-1 (probability or binary)

        Returns:
            Training metrics
        """
        if len(training_data) < 100:
            logger.warning("Insufficient training data")
            return {'error': 'Need at least 100 samples'}

        # Extract features
        X = np.array([
            self._extract_cve_features(cve)
            for cve, _ in training_data
        ])
        y = np.array([label for _, label in training_data])

        # Scale features
        X_scaled = self.scaler.fit_transform(X)

        # Train model
        self.exploit_predictor.fit(X_scaled, y)
        self.is_trained = True

        # Evaluate
        predictions = self.exploit_predictor.predict(X_scaled)
        mse = np.mean((predictions - y) ** 2)
        r2 = self.exploit_predictor.score(X_scaled, y)

        metrics = {
            'samples': len(training_data),
            'mse': float(mse),
            'r2': float(r2),
            'trained_at': datetime.now().isoformat()
        }

        # Save model
        self.save_models()

        return metrics

    def save_models(self):
        """Save models to disk"""
        os.makedirs(self.model_path, exist_ok=True)

        state = {
            'exploit_predictor': self.exploit_predictor,
            'scaler': self.scaler,
            'threat_intel_scores': self.threat_intel_scores,
            'known_exploited': self.known_exploited,
            'is_trained': self.is_trained
        }

        joblib.dump(state, os.path.join(self.model_path, 'vuln_scorer.pkl'))
        logger.info(f"Vulnerability scorer saved to {self.model_path}")

    def load_models(self) -> bool:
        """Load models from disk"""
        model_file = os.path.join(self.model_path, 'vuln_scorer.pkl')

        if not os.path.exists(model_file):
            return False

        try:
            state = joblib.load(model_file)
            self.exploit_predictor = state['exploit_predictor']
            self.scaler = state['scaler']
            self.threat_intel_scores = state['threat_intel_scores']
            self.known_exploited = state['known_exploited']
            self.is_trained = state['is_trained']

            logger.info(f"Vulnerability scorer loaded from {model_file}")
            return True

        except Exception as e:
            logger.error(f"Error loading models: {e}")
            return False

    def get_statistics(self) -> Dict[str, Any]:
        """Get scorer statistics"""
        return {
            'cve_cache_size': len(self.nvd_client.cve_cache),
            'kev_list_size': len(self.nvd_client.kev_list),
            'threat_intel_entries': len(self.threat_intel_scores),
            'known_exploited_cves': len(self.known_exploited),
            'is_trained': self.is_trained
        }


if __name__ == "__main__":
    # Demo usage
    print("Creating Vulnerability Scorer...")
    scorer = VulnerabilityScorer()

    # Test CVEs (famous ones)
    test_cves = [
        "CVE-2021-44228",  # Log4Shell
        "CVE-2017-0144",   # EternalBlue
        "CVE-2014-0160",   # Heartbleed
        "CVE-2019-0708",   # BlueKeep
    ]

    print(f"\nScoring {len(test_cves)} CVEs (fetching from NVD API)...")

    for cve_id in test_cves:
        score = scorer.score_cve(cve_id, AssetCriticality.HIGH)

        if score:
            print(f"\n=== {cve_id} ===")
            print(f"  Base Score: {score.base_score}")
            print(f"  Priority Score: {score.final_priority_score:.1f}/100")
            print(f"  Risk Level: {score.risk_level.name}")
            print(f"  Exploit Maturity: {score.exploit_maturity.value}")
            print(f"  Exploit Probability: {score.exploitability_probability:.2%}")
            print(f"  Time to Exploit: {score.time_to_exploit_days} days")
            print(f"  Recommendations:")
            for rec in score.recommendations[:3]:
                print(f"    - {rec}")
        else:
            print(f"\n{cve_id}: Failed to fetch/score")

    # Get statistics
    stats = scorer.get_statistics()
    print(f"\n=== Scorer Statistics ===")
    print(json.dumps(stats, indent=2))
